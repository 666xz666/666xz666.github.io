<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2025-03-24[DFS]联通性_回溯法</title>
    <link href="/2025/03/24/DFS-%E8%81%94%E9%80%9A%E6%80%A7-%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    <url>/2025/03/24/DFS-%E8%81%94%E9%80%9A%E6%80%A7-%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="DFS-联通性-回溯法"><a href="#DFS-联通性-回溯法" class="headerlink" title="[DFS]联通性_回溯法"></a>[DFS]联通性_回溯法</h1><h2 id="DFS解决连通性问题"><a href="#DFS解决连通性问题" class="headerlink" title="DFS解决连通性问题"></a>DFS解决连通性问题</h2><ul><li>DFS不能保证搜索路径最短</li><li>但是实现代码相对简单</li></ul><h2 id="回溯法暴搜"><a href="#回溯法暴搜" class="headerlink" title="回溯法暴搜"></a>回溯法暴搜</h2><ul><li>回溯法可以暴力枚举一些问题</li><li>一些状态作为dfs函数的参数</li><li>在终点更新某些值</li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="迷宫"><a href="#迷宫" class="headerlink" title="迷宫"></a>迷宫</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// http://ybt.ssoier.cn:8088/problem_show.php?pid=1215</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 联通性问题的DFS解决</span><br><span class="hljs-comment"> * DFS不能保证搜索路径最短</span><br><span class="hljs-comment"> * 但是实现代码相对简单</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">110</span>;<br><br><span class="hljs-type">int</span> xa, ya, xb, yb;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">bool</span> st[N][N];<br><br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x==xb &amp;&amp; y==yb) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  <br>    st[x][y]=<span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">// 这块写法类似BFS</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>        <span class="hljs-type">int</span> a=x+dx[i], b=y+dy[i];<br><br>        <span class="hljs-keyword">if</span>(a&lt;<span class="hljs-number">0</span> || a&gt;=n || b&lt;<span class="hljs-number">0</span> || b&gt;=n) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(st[a][b]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(g[a][b]==<span class="hljs-string">&#x27;#&#x27;</span>) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(a, b)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> k;<br>    cin&gt;&gt;k;<br><br>    <span class="hljs-keyword">while</span>(k--)&#123;<br>        cin&gt;&gt;n;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>            cin&gt;&gt;g[i];<br><br>        cin&gt;&gt;xa&gt;&gt;ya&gt;&gt;xb&gt;&gt;yb;<br><br>        <span class="hljs-built_in">memset</span>(st, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> st);<br>        cout&lt;&lt;(<span class="hljs-built_in">dfs</span>(xa, ya)?<span class="hljs-string">&quot;YES&quot;</span>:<span class="hljs-string">&quot;NO&quot;</span>)&lt;&lt;endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="红与黑"><a href="#红与黑" class="headerlink" title="红与黑"></a>红与黑</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// http://ybt.ssoier.cn:8088/problem_show.php?pid=1216</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 连通性问题DFS</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">30</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> sx, sy;<br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">bool</span> st[N][N];<br><br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">1</span>;<br>    st[x][y]=<span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>        <span class="hljs-type">int</span> a=x+dx[i], b=y+dy[i];<br><br>        <span class="hljs-keyword">if</span>(a&lt;<span class="hljs-number">0</span> || a&gt;=n || b&lt;<span class="hljs-number">0</span> || b&gt;=m) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(st[a][b]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(g[a][b]==<span class="hljs-string">&#x27;#&#x27;</span>) <span class="hljs-keyword">continue</span>;<br><br>        cnt+=<span class="hljs-built_in">dfs</span>(a, b);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;m&gt;&gt;n, m || n)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>                cin&gt;&gt;g[i][j];<br>                <span class="hljs-keyword">if</span>(g[i][j]==<span class="hljs-string">&#x27;@&#x27;</span>) sx=i, sy=j;<br>            &#125;<br>    <br>        <span class="hljs-built_in">memset</span>(st, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> st);<br>        cout&lt;&lt;<span class="hljs-built_in">dfs</span>(sx, sy)&lt;&lt;endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="马走日"><a href="#马走日" class="headerlink" title="马走日"></a>马走日</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// http://ybt.ssoier.cn:8088/problem_show.php?pid=1219</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 回溯法解决问题，参数cnt记录当前已访问了几个结点</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">15</span>;<br><br><span class="hljs-type">int</span> n, m, sx, sy;<br><span class="hljs-type">bool</span> st[N][N];<br><span class="hljs-type">int</span> ans;<br><br><span class="hljs-type">int</span> dx[<span class="hljs-number">8</span>]=&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-2</span>&#125;;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">8</span>]=&#123;<span class="hljs-number">2</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> cnt)</span></span>&#123;<br><br>    <span class="hljs-keyword">if</span>(cnt==n*m)&#123;<br>        ans++;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125; <br><br>    st[x][y]=<span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)&#123;<br>        <span class="hljs-type">int</span> a=x+dx[i], b=y+dy[i];<br><br>        <span class="hljs-keyword">if</span>(a&lt;<span class="hljs-number">0</span> || a&gt;=n || b&lt;<span class="hljs-number">0</span> || b&gt;=m) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(st[a][b]) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-built_in">dfs</span>(a, b, cnt<span class="hljs-number">+1</span>);<br>    &#125;<br><br>    st[x][y]=<span class="hljs-literal">false</span>;<span class="hljs-comment">// 恢复现场</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    cin&gt;&gt;T;<br><br>    <span class="hljs-keyword">while</span>(T--)&#123;<br>        cin&gt;&gt;n&gt;&gt;m&gt;&gt;sx&gt;&gt;sy;<br><br>        <span class="hljs-built_in">memset</span>(st, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> st);<br>        <span class="hljs-built_in">dfs</span>(sx, sy, <span class="hljs-number">1</span>);<br><br>        cout&lt;&lt;ans&lt;&lt;endl;<br><br>        ans=<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单词接龙"><a href="#单词接龙" class="headerlink" title="单词接龙"></a>单词接龙</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// http://ybt.ssoier.cn:8088/problem_show.php?pid=1220</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">25</span>;<br><br><span class="hljs-type">int</span> n;<br>string word[N];<br><span class="hljs-type">int</span> g[N][N];<span class="hljs-comment">// 单词相接最短长度</span><br><span class="hljs-type">int</span> st[N];<br><span class="hljs-type">int</span> ans;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> dragon)</span></span>&#123;<br>    ans=<span class="hljs-built_in">max</span>(ans, dragon);<br><br>    st[u]++;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(st[i]&gt;=<span class="hljs-number">2</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(g[u][i]==<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-built_in">dfs</span>(i, dragon-g[u][i]+word[i].<span class="hljs-built_in">size</span>());<br>    &#125;<br><br>    st[u]--;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;word[i];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            string a=word[i], b=word[j];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-built_in">min</span>(a.<span class="hljs-built_in">size</span>(), b.<span class="hljs-built_in">size</span>());k++)<br>                <span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">substr</span>(a.<span class="hljs-built_in">size</span>()-k, k)==b.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, k))&#123;<br>                    g[i][j]=k;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>        &#125;<br><br>    <span class="hljs-type">char</span> sta;<br>    cin&gt;&gt;sta;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-keyword">if</span>(word[i][<span class="hljs-number">0</span>]==sta)<br>            <span class="hljs-built_in">dfs</span>(i, word[i].<span class="hljs-built_in">size</span>());<br><br>    cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分成互质组"><a href="#分成互质组" class="headerlink" title="分成互质组"></a>分成互质组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// http://ybt.ssoier.cn:8088/problem_show.php?pid=1221</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">15</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> p[N];<br><span class="hljs-type">int</span> group[N][N];<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-type">int</span> ans=N;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> g, <span class="hljs-type">int</span> gc, <span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;gc;i++)<br>        <span class="hljs-keyword">if</span>(__gcd(group[g][i], x) &gt; <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> sta, <span class="hljs-comment">// 组合的方式, 从哪个数开始讨论, 当前数加入当前组, 不加人</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">int</span> g, <span class="hljs-comment">// 当前最后一组</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">int</span> gc, <span class="hljs-comment">// 当前最后一组的元素个数</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">int</span> cnt <span class="hljs-comment">// 已经给多少个数分组</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(g&gt;=ans) <span class="hljs-keyword">return</span> ;<span class="hljs-comment">// 优化 </span><br>    <span class="hljs-keyword">if</span>(cnt==n) ans=<span class="hljs-built_in">min</span>(ans, g);<br><br>    <span class="hljs-type">bool</span> flag=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=sta;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(st[i]) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(g, gc, p[i]))&#123;<br>            st[i]=<span class="hljs-literal">true</span>;<br>            group[g][gc]=p[i];<br>            <span class="hljs-built_in">dfs</span>(i<span class="hljs-number">+1</span>, g, gc<span class="hljs-number">+1</span>, cnt<span class="hljs-number">+1</span>);<br>            st[i]=<span class="hljs-literal">false</span>;<br><br>            flag=<span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(flag) <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, g<span class="hljs-number">+1</span>, <span class="hljs-number">0</span>, cnt);<span class="hljs-comment">// 没有数能加入当前组,新建组</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;p[i];<br><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>    cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>寒假练题计划</category>
      
      <category>提高算法</category>
      
      <category>搜索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>algorithm</tag>
      
      <tag>ACwing</tag>
      
      <tag>DFS</tag>
      
      <tag>Backtracking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025-03-23[BFS]双向BFS_A*算法</title>
    <link href="/2025/03/23/BFS-%E5%8F%8C%E5%90%91BFS-A-%E7%AE%97%E6%B3%95/"/>
    <url>/2025/03/23/BFS-%E5%8F%8C%E5%90%91BFS-A-%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="BFS-双向BFS-A-算法"><a href="#BFS-双向BFS-A-算法" class="headerlink" title="[BFS]双向BFS&amp;A*算法"></a>[BFS]双向BFS&amp;A*算法</h1><h2 id="双向广搜"><a href="#双向广搜" class="headerlink" title="双向广搜"></a>双向广搜</h2><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a><strong>核心思想</strong></h4><ul><li>从起点和终点同时开始搜索，每次扩展一层，直到两个方向的搜索路径相遇。</li><li>适用于求解最小步数问题，尤其是搜索空间较大时，可以显著优化搜索效率。</li></ul><h4 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a><strong>关键点</strong></h4><ul><li><strong>队列和哈希表的使用</strong>：<ul><li>使用两个队列分别存储从起点和终点出发的待扩展状态。</li><li>使用两个哈希表分别记录从起点和终点出发到达每个状态的步数。</li></ul></li><li><strong>扩展策略</strong>：<ul><li>每次从队列中取出一个状态，尝试所有可能的转换。</li><li>如果转换后的状态在对方方向的哈希表中出现，则找到了一条路径。</li></ul></li><li><strong>终止条件</strong>：<ul><li>如果两个方向的<code>队列之一</code>为空，说明无法找到路径。</li><li>如果扩展的<code>层数</code>超过某个<code>阈值</code>（如10），可以提前终止以避免无限搜索。</li></ul></li></ul><h2 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a>A*算法</h2><h4 id="核心思想-1"><a href="#核心思想-1" class="headerlink" title="核心思想"></a><strong>核心思想</strong></h4><ul><li>A*算法是一种启发式搜索算法，结合了广度优先搜索（BFS）和启发式函数。</li><li>通过启发式函数估计从当前状态到达目标状态的代价，从而优化搜索过程。</li></ul><h4 id="关键点-1"><a href="#关键点-1" class="headerlink" title="关键点"></a><strong>关键点</strong></h4><ul><li><strong>启发式函数</strong>：<ul><li>选择合适的启发式函数是关键，启发式函数需要满足<strong>可接受性</strong>（即估计值不超过真实值）。</li><li>在八数码问题中，启发式函数是曼哈顿距离，即每个数字当前位置到目标位置的绝对距离之和。</li></ul></li><li><strong>优先队列</strong>：<ul><li>使用优先队列存储待扩展状态，队列中的状态按照启发式函数值排序。</li><li>每次扩展启发式函数值最小的状态。</li></ul></li><li><strong>路径记录</strong>：<ul><li>使用哈希表记录从初始状态到达每个状态的路径，以便在找到目标状态时输出路径。</li></ul></li></ul><h4 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a><strong>实现细节</strong></h4><ul><li>在扩展状态时，需要检查新状态是否已经访问过，并且路径长度是否更短。如果<code>新路径更长</code>，则<code>跳过</code>该状态。</li><li>A*算法<code>不能保证</code>搜索过程中的<code>每一步</code>都是<code>最短路径</code>，但<code>最终找到</code>的路径是最短路径。</li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="子串变换"><a href="#子串变换" class="headerlink" title="子串变换"></a>子串变换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://www.acwing.com/problem/content/192/</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 双向广搜一般用于最小步数模型</span><br><span class="hljs-comment"> * 对于搜素空间较大的问题可以优化</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 每次可以拓展队列的一层</span><br><span class="hljs-comment"> * 当拓展层数超过10，可以直接退出了</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">6</span>;<br><br>string A, B;<br><span class="hljs-type">int</span> n;<br>string a[N], b[N];<br>queue&lt;string&gt; qa, qb;<br>unordered_map&lt;string, <span class="hljs-type">int</span>&gt; da, db;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">extend</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    queue&lt;string&gt; &amp;qa,</span></span><br><span class="hljs-params"><span class="hljs-function">    unordered_map&lt;string, <span class="hljs-type">int</span>&gt; &amp;da,</span></span><br><span class="hljs-params"><span class="hljs-function">    unordered_map&lt;string, <span class="hljs-type">int</span>&gt; &amp;db,</span></span><br><span class="hljs-params"><span class="hljs-function">    string a[],</span></span><br><span class="hljs-params"><span class="hljs-function">    string b[] </span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>&#123;<br>    <span class="hljs-type">int</span> cnt=qa.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-keyword">while</span>(cnt--)&#123;<br>        string t=qa.<span class="hljs-built_in">front</span>();<br>        qa.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;t.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(t.<span class="hljs-built_in">substr</span>(i, a[j].<span class="hljs-built_in">size</span>())==a[j])&#123;<br>                    string state=t.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, i)+b[j]+t.<span class="hljs-built_in">substr</span>(i+a[j].<span class="hljs-built_in">size</span>());<br><br>                    <span class="hljs-comment">// cout&lt;&lt;&quot;state: &quot;&lt;&lt;state&lt;&lt;endl;</span><br>                    <br>                    <span class="hljs-keyword">if</span>(db.<span class="hljs-built_in">count</span>(state)) <span class="hljs-keyword">return</span> da[t]<span class="hljs-number">+1</span>+db[state];<span class="hljs-comment">// 不管有没有遍历过，都要尝试一下两边是否都遍历到</span><br>                    <br>                    <span class="hljs-keyword">if</span>(da.<span class="hljs-built_in">count</span>(state)) <span class="hljs-keyword">continue</span>;<br><br>                    qa.<span class="hljs-built_in">push</span>(state);<br>                    da[state]=da[t]<span class="hljs-number">+1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">11</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(string A, string B)</span></span>&#123;<br>    qa.<span class="hljs-built_in">push</span>(A), qb.<span class="hljs-built_in">push</span>(B);<br>    da[A]=<span class="hljs-number">0</span>, db[B]=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(qa.<span class="hljs-built_in">size</span>() &amp;&amp; qb.<span class="hljs-built_in">size</span>())&#123;<span class="hljs-comment">// 有一个队列已经空了，还没找到，说明不联通</span><br>        <span class="hljs-type">int</span> t;<br>        <span class="hljs-keyword">if</span>(qa.<span class="hljs-built_in">size</span>()&lt;=qb.<span class="hljs-built_in">size</span>()) t=<span class="hljs-built_in">extend</span>(qa, da, db, a, b);<br>        <span class="hljs-keyword">else</span> t=<span class="hljs-built_in">extend</span>(qb, db, da, b, a);<br><br>        <span class="hljs-keyword">if</span>(t&lt;=<span class="hljs-number">10</span>) <span class="hljs-keyword">return</span> t;<br>        <span class="hljs-keyword">if</span>(++cnt&gt;<span class="hljs-number">10</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">11</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">11</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;A&gt;&gt;B;<br><br>    <span class="hljs-keyword">if</span>(A==B)&#123;<br>        cout&lt;&lt;<span class="hljs-number">0</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;a[n]&gt;&gt;b[n]) n++;<br><br>    <span class="hljs-type">int</span> step=<span class="hljs-built_in">bfs</span>(A, B);<br>    <span class="hljs-keyword">if</span>(step&gt;<span class="hljs-number">10</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO ANSWER!&quot;</span>);<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;step&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="八数码"><a href="#八数码" class="headerlink" title="八数码"></a>八数码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://www.acwing.com/problem/content/181/</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A*算法优化BFS</span><br><span class="hljs-comment"> * 估价函数定义为当前点离起点的真实距离加上离终点的估计距离（要求估计距离&lt;=真实距离）</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * A*算法只能保证终点是最短路径</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, string&gt; PIS;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(string state, string ed=<span class="hljs-string">&quot;12345678x&quot;</span>)</span></span>&#123;<span class="hljs-comment">// 估价函数</span><br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>        <span class="hljs-keyword">if</span>(state[i]!=<span class="hljs-string">&#x27;x&#x27;</span>)&#123;<br>            <span class="hljs-type">int</span> x=i/<span class="hljs-number">3</span>, y=i%<span class="hljs-number">3</span>;<br>            <span class="hljs-type">int</span> num=state[i]-<span class="hljs-string">&#x27;1&#x27;</span>;<br>            res+= <span class="hljs-built_in">abs</span>(x-num/<span class="hljs-number">3</span>)+<span class="hljs-built_in">abs</span>(y-num%<span class="hljs-number">3</span>);<br>        &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function">string <span class="hljs-title">bfs</span><span class="hljs-params">(string sta, string ed)</span></span>&#123;<br>    priority_queue&lt;PIS, vector&lt;PIS&gt;, greater&lt;PIS&gt;&gt; q;<br>    unordered_map&lt;string, string&gt; d;<br><br>    q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>+<span class="hljs-built_in">f</span>(sta) ,sta&#125;);<br>    d[sta]=<span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-keyword">auto</span>[w, t]=q.<span class="hljs-built_in">top</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-keyword">if</span>(t==ed) <span class="hljs-keyword">return</span> d[t];<br><br>        <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">char</span> op[<span class="hljs-number">4</span>]=&#123;<span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>&#125;;<br><br>        <span class="hljs-type">int</span> u;<br>        <span class="hljs-keyword">for</span>(u=<span class="hljs-number">0</span>;u&lt;<span class="hljs-number">9</span>;u++)<br>            <span class="hljs-keyword">if</span>(t[u]==<span class="hljs-string">&#x27;x&#x27;</span>) <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-type">int</span> x0=u/<span class="hljs-number">3</span>, y0=u%<span class="hljs-number">3</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>            <span class="hljs-type">int</span> x=x0+dx[i], y=y0+dy[i];<br>            <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span> || x&gt;=<span class="hljs-number">3</span> || y&lt;<span class="hljs-number">0</span> || y&gt;=<span class="hljs-number">3</span>) <span class="hljs-keyword">continue</span>;<br><br>            string state=t;<br>            <span class="hljs-built_in">swap</span>(state[x0*<span class="hljs-number">3</span>+y0], state[x*<span class="hljs-number">3</span>+y]);<br><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 这里注意，A*算法过程中不能保证最短路径，</span><br><span class="hljs-comment">             * 所以一个节点可能多次入队，标准是是否被更新，</span><br><span class="hljs-comment">             * 就像dijkstra，</span><br><span class="hljs-comment">             * 严格来说，dijkstra是特殊的A*算法</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-keyword">if</span>(d.<span class="hljs-built_in">count</span>(state) &amp;&amp; d[state].<span class="hljs-built_in">size</span>()&lt;d[t].<span class="hljs-built_in">size</span>()<span class="hljs-number">+1</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">// 不能更新</span><br><br>            d[state]=d[t]+op[i];<br>            q.<span class="hljs-built_in">push</span>(&#123;d[state].<span class="hljs-built_in">size</span>()+<span class="hljs-built_in">f</span>(state), state&#125;);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;error&quot;</span>;<span class="hljs-comment">// 不可能到达</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    string sta, ed=<span class="hljs-string">&quot;12345678x&quot;</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)&#123;<br>        <span class="hljs-type">char</span> c;<br>        cin&gt;&gt;c;<br>        sta+=c;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算逆序对数量</span><br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">+1</span>;j&lt;<span class="hljs-number">9</span>;j++)<br>            <span class="hljs-keyword">if</span>(sta[i]!=<span class="hljs-string">&#x27;x&#x27;</span> &amp;&amp; sta[j]!=<span class="hljs-string">&#x27;x&#x27;</span> &amp;&amp; sta[i]&gt;sta[j]) cnt++;<br><br>    <span class="hljs-keyword">if</span>(cnt &amp; <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">// 逆序对个数为奇数，无解</span><br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;unsolvable&quot;</span>);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    string res=<span class="hljs-built_in">bfs</span>(sta, ed);<br><br>    cout&lt;&lt;res&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第K短路"><a href="#第K短路" class="headerlink" title="第K短路"></a>第K短路</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://www.acwing.com/problem/content/180/</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * BFS终点第K次出队，得到的距离就是第K小</span><br><span class="hljs-comment"> * A*算法的估价函数使用反向dijstra获取的距离</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second </span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1010</span>, M=<span class="hljs-number">20010</span>;<span class="hljs-comment">// 前向星同时存正反两边</span><br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, PII&gt; PIII;<br><br><span class="hljs-type">int</span> n, m, S, T, K;<br><span class="hljs-type">int</span> h[N], rh[N], e[M], w[M], ne[M], idx;<br><span class="hljs-type">int</span> dist[N];<span class="hljs-comment">// 估价</span><br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> h[], <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span>&#123;<br>    e[idx]=b, w[idx]=c, ne[idx]=h[a], h[a]=idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijstra</span><span class="hljs-params">(<span class="hljs-type">int</span> sta, <span class="hljs-type">int</span> ed)</span></span>&#123;<br>    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;<br>    heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, sta&#125;);<br><br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[sta]=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(st, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> st);<br><br>    <span class="hljs-keyword">while</span>(heap.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-keyword">auto</span>[d, t]=heap.<span class="hljs-built_in">top</span>();<br>        heap.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-keyword">if</span>(st[t]) <span class="hljs-keyword">continue</span>;<br>        st[t]=<span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=rh[t];~i;i=ne[i])&#123;<br>            <span class="hljs-type">int</span> j=e[i];<br>            <span class="hljs-keyword">if</span>(dist[j]&gt;dist[t]+w[i])&#123;<br>                dist[j]=dist[t]+w[i];<br>                heap.<span class="hljs-built_in">push</span>(&#123;dist[j], j&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">astar</span><span class="hljs-params">(<span class="hljs-type">int</span> sta, <span class="hljs-type">int</span> ed)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(dist[sta]==<span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">// 不联通</span><br><br>    priority_queue&lt;PIII, vector&lt;PIII&gt;, greater&lt;PIII&gt;&gt; heap;<br>    heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>+dist[sta], &#123;<span class="hljs-number">0</span>, sta&#125;&#125;);<br><br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(heap.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-keyword">auto</span>[val, u]=heap.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-keyword">auto</span>[d, t]=u;<br>        heap.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-keyword">if</span>(t==ed) cnt++;<br>        <span class="hljs-keyword">if</span>(cnt==K) <span class="hljs-keyword">return</span> d;<br><br>        <span class="hljs-comment">// 数据有自环</span><br>        <span class="hljs-keyword">if</span>(d&gt;<span class="hljs-number">1e6</span><span class="hljs-number">+10</span>) <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[t];~i;i=ne[i])&#123;<br>            <span class="hljs-type">int</span> j=e[i];<br>            heap.<span class="hljs-built_in">push</span>(&#123;d+w[i]+dist[j], &#123;d+w[i], j&#125;&#125;);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br><br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-built_in">memset</span>(rh, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> rh);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        <span class="hljs-built_in">add</span>(h, a, b, c), <span class="hljs-built_in">add</span>(rh, b, a, c);<br>    &#125;<br><br>    cin&gt;&gt;S&gt;&gt;T&gt;&gt;K;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当起点和终点相同时，K中隐含了一条长度为0的没有边的最短路，</span><br><span class="hljs-comment">     * 但这条路是不对的，因为起点和终点至少包含一条边，</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">if</span>(S==T) K++;<span class="hljs-comment">//  每条最短路中至少要包含一条边</span><br><br>    <span class="hljs-built_in">dijstra</span>(T, S);<br><br>    <span class="hljs-type">int</span> res=<span class="hljs-built_in">astar</span>(S, T);<br><br>    cout&lt;&lt;res&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>寒假练题计划</category>
      
      <category>提高算法</category>
      
      <category>搜索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>algorithm</tag>
      
      <tag>ACwing</tag>
      
      <tag>BFS</tag>
      
      <tag>Shortest-Path</tag>
      
      <tag>A*</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025-03-22[BFS]多源BFS_最小步_双端队列</title>
    <link href="/2025/03/22/BFS-%E5%A4%9A%E6%BA%90BFS-%E6%9C%80%E5%B0%8F%E6%AD%A5-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/"/>
    <url>/2025/03/22/BFS-%E5%A4%9A%E6%BA%90BFS-%E6%9C%80%E5%B0%8F%E6%AD%A5-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="BFS-多源BFS-最小步-双端队列"><a href="#BFS-多源BFS-最小步-双端队列" class="headerlink" title="[BFS]多源BFS&amp;最小步&amp;双端队列"></a>[BFS]多源BFS&amp;最小步&amp;双端队列</h1><h2 id="多源BFS"><a href="#多源BFS" class="headerlink" title="多源BFS"></a>多源BFS</h2><ul><li><strong>定义</strong>：从多个起点同时开始的BFS。</li><li><strong>实现方法</strong>：<ul><li>将<code>所有起点</code>同时加入队列。</li><li>从这些起点开始，按照BFS的规则进行遍历。</li></ul></li></ul><h2 id="最小步模型"><a href="#最小步模型" class="headerlink" title="最小步模型"></a>最小步模型</h2><ul><li><strong>定义</strong>：求解从起点到终点的最小操作步数。</li><li><strong>实现方法</strong>：<ul><li>使用BFS，将每次操作视为一步。</li><li>每次从队列中取出当前状态，尝试所有可能的操作，生成新的状态并加入队列。</li><li>使用<code>哈希表</code>记录状态的前驱，以便回溯路径。</li></ul></li></ul><h2 id="双端队列广搜"><a href="#双端队列广搜" class="headerlink" title="双端队列广搜"></a>双端队列广搜</h2><ul><li><strong>定义</strong>：使用双端队列（deque）优化BFS，适用于边权为0或1的最短路径问题。</li><li><strong>实现方法</strong>：<ul><li>使用双端队列代替普通队列。</li><li>当遇到权值为0的边时，将节点加入队列头部；遇到权值为1的边时，加入队列尾部。</li><li>这种情况实际上是<code>Dijkstra算法</code>的特殊情况，因为边权<code>只有0和1</code>。</li></ul></li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="矩阵距离"><a href="#矩阵距离" class="headerlink" title="矩阵距离"></a>矩阵距离</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://www.acwing.com/problem/content/175/</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * BFS解决多起点的最短路径问题</span><br><span class="hljs-comment"> * 解决的思路是提前将所有起点加入BFS的队列中，然后正常执行BFS操作</span><br><span class="hljs-comment"> * 可以这样理解：有一个虚拟起点，它到所有起点的距离都是0，</span><br><span class="hljs-comment"> * 这样问题就转换成了求以虚拟点为起点的最短路径！</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1010</span>, M=N*N;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">bool</span> g[N][N];<br><span class="hljs-type">bool</span> st[N][N];<br>PII q[M];<br><span class="hljs-type">int</span> hh, tt;<br>PII pre[N][N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-keyword">while</span>(hh&lt;=tt)&#123;<br>        PII t=q[hh++];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>            <span class="hljs-type">int</span> x=t.x+dx[i], y=t.y+dy[i];<br><br>            <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span> || x&gt;=n || y&lt;<span class="hljs-number">0</span> || y&gt;=m) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(st[x][y]) <span class="hljs-keyword">continue</span>;<br><br>            q[++tt]=&#123;x, y&#125;;<br>            st[x][y]=<span class="hljs-literal">true</span>;<br><br>            pre[x][y]=t;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><br>    hh=<span class="hljs-number">0</span>, tt=<span class="hljs-number">-1</span>;<br>    <span class="hljs-built_in">memset</span>(pre, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> pre);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">char</span> s[M];<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot; %s&quot;</span>, s);<br>        <span class="hljs-comment">// printf(&quot;s: %s\n&quot;, s);</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            g[i][j]=s[j]-<span class="hljs-string">&#x27;0&#x27;</span>;<br><br>            <span class="hljs-keyword">if</span>(g[i][j])&#123;<br>                q[++tt]=&#123;i, j&#125;;<br>                st[i][j]=<span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">bfs</span>();<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            <span class="hljs-keyword">if</span>(g[i][j])&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            PII end=&#123;i, j&#125;;<br>            <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                cnt++;<br>                <span class="hljs-keyword">if</span>(g[end.x][end.y]) <span class="hljs-keyword">break</span>;<br>                end=pre[end.x][end.y];<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, cnt<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="魔板"><a href="#魔板" class="headerlink" title="魔板"></a>魔板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// http://ybt.ssoier.cn:8088/problem_show.php?pid=1449</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 最小步模型，实际上是用BFS解决单起点最短路径问题</span><br><span class="hljs-comment"> * 关键在于如何存储状态</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>string sta=<span class="hljs-string">&quot;12345678&quot;</span>, ed;<br>unordered_map&lt;string, pair&lt;string, <span class="hljs-type">char</span>&gt;&gt; pre;<br>queue&lt;string&gt; qu;<br><span class="hljs-type">int</span> g[<span class="hljs-number">2</span>][<span class="hljs-number">4</span>];<br><br><span class="hljs-function">string <span class="hljs-title">getG</span><span class="hljs-params">()</span></span>&#123;<br>    string res;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++) res+=g[<span class="hljs-number">0</span>][i]+<span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&gt;=<span class="hljs-number">0</span>;i--) res+=g[<span class="hljs-number">1</span>][i]+<span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">return</span> res; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setG</span><span class="hljs-params">(string s)</span></span>&#123;<br>    <span class="hljs-comment">// cout&lt;&lt;&quot;setG&quot;&lt;&lt;endl;</span><br>    <span class="hljs-comment">// cout&lt;&lt;&quot;s: &quot;&lt;&lt;s&lt;&lt;endl;</span><br>    <span class="hljs-type">int</span> idx=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++) g[<span class="hljs-number">0</span>][i]=s[idx++]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&gt;=<span class="hljs-number">0</span>;i--) g[<span class="hljs-number">1</span>][i]=s[idx++]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-comment">// for(int i=0;i&lt;2;i++)&#123;</span><br>    <span class="hljs-comment">//     for(int j=0;j&lt;4;j++) </span><br>    <span class="hljs-comment">//         cout&lt;&lt;g[i][j]&lt;&lt;&quot; &quot;;</span><br>    <span class="hljs-comment">//     cout&lt;&lt;endl;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// while(true)&#123;&#125;</span><br>&#125;<br><br><span class="hljs-function">string <span class="hljs-title">moveA</span><span class="hljs-params">(string s)</span></span>&#123;<br>    <span class="hljs-built_in">setG</span>(s);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++) <span class="hljs-built_in">swap</span>(g[<span class="hljs-number">0</span>][i], g[<span class="hljs-number">1</span>][i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">getG</span>();<br>&#125;<br><br><span class="hljs-function">string <span class="hljs-title">moveB</span><span class="hljs-params">(string s)</span></span>&#123;<br>    <span class="hljs-built_in">setG</span>(s);<br>    <span class="hljs-type">int</span> x03=g[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>], x13=g[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&gt;=<span class="hljs-number">1</span>;i--) g[<span class="hljs-number">0</span>][i]=g[<span class="hljs-number">0</span>][i<span class="hljs-number">-1</span>], g[<span class="hljs-number">1</span>][i]=g[<span class="hljs-number">1</span>][i<span class="hljs-number">-1</span>];<br>    g[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=x03, g[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=x13;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">getG</span>();<br>&#125;<br><br><span class="hljs-function">string <span class="hljs-title">moveC</span><span class="hljs-params">(string s)</span></span>&#123;<br>    <span class="hljs-built_in">setG</span>(s);<br>    <span class="hljs-type">int</span> tmp=g[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>    g[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=g[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>    g[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=g[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br>    g[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]=g[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>];<br>    g[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]=tmp;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">getG</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<br>    qu.<span class="hljs-built_in">push</span>(sta);<br>    pre[sta]=&#123;<span class="hljs-string">&quot;null&quot;</span>, <span class="hljs-string">&#x27;X&#x27;</span>&#125;;<br><br>    <span class="hljs-keyword">while</span>(qu.<span class="hljs-built_in">size</span>())&#123;<br>        string state=qu.<span class="hljs-built_in">front</span>();<br>        qu.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-comment">// 按照字典序尝试操作，可以保证最后的结果符合最小字典序</span><br>        string stateA=<span class="hljs-built_in">moveA</span>(state);<br>        <span class="hljs-keyword">if</span>(pre.<span class="hljs-built_in">count</span>(stateA)==<span class="hljs-number">0</span>)&#123;<br>            qu.<span class="hljs-built_in">push</span>(stateA);<br>            pre[stateA]=&#123;state, <span class="hljs-string">&#x27;A&#x27;</span>&#125;;<br>            <span class="hljs-keyword">if</span>(stateA==ed) <span class="hljs-keyword">break</span>;<br>        &#125; <br><br>        string stateB=<span class="hljs-built_in">moveB</span>(state);<br>        <span class="hljs-keyword">if</span>(pre.<span class="hljs-built_in">count</span>(stateB)==<span class="hljs-number">0</span>)&#123;<br>            qu.<span class="hljs-built_in">push</span>(stateB);<br>            pre[stateB]=&#123;state, <span class="hljs-string">&#x27;B&#x27;</span>&#125;;<br>            <span class="hljs-keyword">if</span>(stateB==ed) <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        string stateC=<span class="hljs-built_in">moveC</span>(state);<br>        <span class="hljs-keyword">if</span>(pre.<span class="hljs-built_in">count</span>(stateC)==<span class="hljs-number">0</span>)&#123;<br>            qu.<span class="hljs-built_in">push</span>(stateC);<br>            pre[stateC]=&#123;state, <span class="hljs-string">&#x27;C&#x27;</span>&#125;;<br>            <span class="hljs-keyword">if</span>(stateC==ed) <span class="hljs-keyword">break</span>;<br>        &#125; <br><br>        <span class="hljs-comment">// cout&lt;&lt;state&lt;&lt;&quot; &quot;&lt;&lt;stateA&lt;&lt;&quot; &quot;&lt;&lt;stateB&lt;&lt;&quot; &quot;&lt;&lt;stateC&lt;&lt;endl;</span><br>        <span class="hljs-comment">// while(true)&#123;&#125;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)&#123;<br>        <span class="hljs-type">int</span> x;<br>        cin&gt;&gt;x;<br>        ed+=x+<span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-comment">// cout&lt;&lt;ed;</span><br><br>    <span class="hljs-built_in">bfs</span>();<br><br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    stack&lt;<span class="hljs-type">char</span>&gt; Stack;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        cnt++;<br><br>        <span class="hljs-keyword">if</span>(ed==sta) <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">auto</span> [state, op]=pre[ed];<br>        Stack.<span class="hljs-built_in">push</span>(op);<br>        ed=state;<br>    &#125;<br><br>    cout&lt;&lt;cnt<span class="hljs-number">-1</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">while</span>(Stack.<span class="hljs-built_in">size</span>()) cout&lt;&lt;Stack.<span class="hljs-built_in">top</span>(), Stack.<span class="hljs-built_in">pop</span>();<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="电路维修"><a href="#电路维修" class="headerlink" title="电路维修"></a>电路维修</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://www.acwing.com/problem/content/177/</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 首先要发现一个很重要的性质，同一条路径中不可能同时包含一个元件的四个点</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 可到达的点横、纵坐标和必须为偶数</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 所以对于一个元件的两条对角线，本来已连接的，权重视为0，未连接的视为1（要旋转一次）</span><br><span class="hljs-comment"> * 这样就变成了边权只有0和1的最短路径问题</span><br><span class="hljs-comment"> * 对于此我们可以使用双端队列模拟优先队列，用BFS解决</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 其实是dijstra的特殊情况</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">510</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-comment">// 边0~n-1,0~m-1</span><br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">int</span> st[N][N];<span class="hljs-comment">// 已经用作更新的边不能再用</span><br><br><span class="hljs-comment">// 点0~n,0~m</span><br>deque&lt;PII&gt; q;<br><span class="hljs-type">int</span> dist[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> sx, <span class="hljs-type">int</span> sy)</span></span>&#123;<br>    q.<span class="hljs-built_in">clear</span>();<br>    q.<span class="hljs-built_in">push_back</span>(&#123;sx, sy&#125;);<br><br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[sx][sy]=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-type">char</span> cs[<span class="hljs-number">4</span>]=&#123;<span class="hljs-string">&#x27;\\&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;\\&#x27;</span>&#125;;<br><br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>        PII t=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop_front</span>();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>            <span class="hljs-type">int</span> x=t.x+dx[i], y=t.y+dy[i];<br>            <span class="hljs-type">int</span> u=<span class="hljs-built_in">min</span>(t.x, x), v=<span class="hljs-built_in">min</span>(t.y, y);<span class="hljs-comment">// 元件的坐标</span><br><br>            <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span> || x&gt;n || y&lt;<span class="hljs-number">0</span> || y&gt;m) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(u&lt;<span class="hljs-number">0</span> || u&gt;=n || v&lt;<span class="hljs-number">0</span> || v&gt;=m) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(st[u][v]) <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-type">int</span> w=g[u][v]!=cs[i];<br>            <span class="hljs-keyword">if</span>(w) q.<span class="hljs-built_in">push_back</span>(&#123;x, y&#125;);<br>            <span class="hljs-keyword">else</span> q.<span class="hljs-built_in">push_front</span>(&#123;x, y&#125;);<br><br>            dist[x][y]=<span class="hljs-built_in">min</span>(dist[x][y], dist[t.x][t.y]+w);<br><br>            st[u][v]=<span class="hljs-literal">true</span>;<br><br>            <span class="hljs-keyword">if</span>(x==n &amp;&amp; y==m) <span class="hljs-keyword">return</span> dist[x][y];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">// 不可能到达</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    cin&gt;&gt;T;<br><br>    <span class="hljs-keyword">while</span>(T--)&#123;<br>        cin&gt;&gt;n&gt;&gt;m;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)<br>                cin&gt;&gt;g[i][j];<br><br>        <span class="hljs-keyword">if</span>(n+m &amp; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO SOLUTION&quot;</span>);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>            <br>        <span class="hljs-built_in">memset</span>(st, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> st);<br>        cout&lt;&lt;<span class="hljs-built_in">bfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)&lt;&lt;endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br><br>    <span class="hljs-comment">// char c;</span><br>    <span class="hljs-comment">// cin&gt;&gt;c;</span><br>    <span class="hljs-comment">// cout&lt;&lt;(c==&#x27;\\&#x27;);</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>寒假练题计划</category>
      
      <category>提高算法</category>
      
      <category>搜索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>algorithm</tag>
      
      <tag>ACwing</tag>
      
      <tag>BFS</tag>
      
      <tag>Flood-Fill</tag>
      
      <tag>Shortest-Path</tag>
      
      <tag>double-ended queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025-03-21[BFS]Flood-Fill&amp;最短路径</title>
    <link href="/2025/03/21/BFS-Flood-Fill-ShortestRoute/"/>
    <url>/2025/03/21/BFS-Flood-Fill-ShortestRoute/</url>
    
    <content type="html"><![CDATA[<h1 id="BFS-Flood-Fill-最短路径"><a href="#BFS-Flood-Fill-最短路径" class="headerlink" title="[BFS]Flood-Fill&amp;最短路径"></a>[BFS]Flood-Fill&amp;最短路径</h1><h2 id="Flood-Fill的BFS实现"><a href="#Flood-Fill的BFS实现" class="headerlink" title="Flood-Fill的BFS实现"></a>Flood-Fill的BFS实现</h2><p><strong>Flood-Fill（洪水填充算法）</strong> 是一种基于 BFS 的算法，用于填充一个区域，直到遇到边界。它常用于图像处理、迷宫生成和游戏开发等领域。</p><p>通过这种算法，我们可以得到一张图中有<code>多少联通块</code>，以及各联通块中的一些<code>性质</code>。</p><h2 id="BFS的最短路性质"><a href="#BFS的最短路性质" class="headerlink" title="BFS的最短路性质"></a>BFS的最短路性质</h2><p>BFS 从起点开始逐层遍历，因此它能够找到从<code>起点</code>到<code>任意点</code>的<code>最短路径</code>（<code>无权图</code>）。在每次扩展节点时，BFS 保证了路径的长度是逐步增加的。</p><p>针对最短路径问题，我们可以从起点开始BFS，结束后再从终点开始回溯，可以得到最短路径的<code>逆路径</code>，顺便获取<code>路径长度</code>。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="池塘计数"><a href="#池塘计数" class="headerlink" title="池塘计数"></a>池塘计数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://iai.sh.cn/problem/948</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * BFS求联通块数量</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1010</span>, M=N*N;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">char</span> g[N][N];<br>PII q[M];<br><span class="hljs-type">int</span> hh, tt;<br><span class="hljs-type">bool</span> st[N][N];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span> || i&gt;=n || j&lt;<span class="hljs-number">0</span> || j&gt;=m) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>(g[i][j]==<span class="hljs-string">&#x27;#&#x27;</span> || st[i][j]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span>&#123;<br>    q[++tt]=&#123;i, j&#125;;<br>    st[i][j]=<span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x0, <span class="hljs-type">int</span> y0)</span></span>&#123;<br>    hh=<span class="hljs-number">0</span>, tt=<span class="hljs-number">0</span>;<br>    q[<span class="hljs-number">0</span>]=&#123;x0, y0&#125;;<br>    st[x0][y0]=<span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">while</span>(hh&lt;=tt)&#123;<br>        <span class="hljs-keyword">auto</span> [x, y]=q[hh++];<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(x<span class="hljs-number">-1</span>, y)) <span class="hljs-built_in">push</span>(x<span class="hljs-number">-1</span>, y);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(x<span class="hljs-number">+1</span>, y)) <span class="hljs-built_in">push</span>(x<span class="hljs-number">+1</span>, y);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(x, y<span class="hljs-number">-1</span>)) <span class="hljs-built_in">push</span>(x, y<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(x, y<span class="hljs-number">+1</span>)) <span class="hljs-built_in">push</span>(x, y<span class="hljs-number">+1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, g[i]);<br><br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)<br>            <span class="hljs-keyword">if</span>(g[i][j]==<span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; !st[i][j])&#123;<br>                <span class="hljs-built_in">bfs</span>(i, j);<br>                cnt++;<br>            &#125;<br>    <br>    cout&lt;&lt;cnt&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="城堡问题"><a href="#城堡问题" class="headerlink" title="城堡问题"></a>城堡问题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// // http://noi.openjudge.cn/ch0205/1817/</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 同样是BFS求联通块数量，连通性需要翻译；此外还求了联通快的大小</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">60</span>, M=N*N;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-type">bool</span> st[N][N];<br>PII q[M];<br><span class="hljs-type">int</span> hh, tt;<br><br><span class="hljs-type">int</span> ans2=<span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span> || i&gt;=n || j&lt;<span class="hljs-number">0</span> || j&gt;=m) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>(st[i][j]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span>&#123;<br>    q[++tt]=&#123;i, j&#125;;<br>    st[i][j]=<span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> sx, <span class="hljs-type">int</span> sy)</span></span>&#123;<br>    hh=tt=<span class="hljs-number">0</span>;<br>    q[<span class="hljs-number">0</span>]=&#123;sx, sy&#125;;<br>    st[sx][sy]=<span class="hljs-literal">true</span>;<br><br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span>(hh&lt;=tt)&#123;<br>        <span class="hljs-keyword">auto</span> [x, y]=q[hh++];<br>        <span class="hljs-type">int</span> f=g[x][y];<br><br>        sum++;<br><br>        <span class="hljs-keyword">if</span>(!(f&gt;&gt;<span class="hljs-number">0</span>&amp;<span class="hljs-number">1</span>) &amp;&amp; <span class="hljs-built_in">check</span>(x, y<span class="hljs-number">-1</span>)) <span class="hljs-built_in">push</span>(x, y<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">if</span>(!(f&gt;&gt;<span class="hljs-number">1</span>&amp;<span class="hljs-number">1</span>) &amp;&amp; <span class="hljs-built_in">check</span>(x<span class="hljs-number">-1</span>, y)) <span class="hljs-built_in">push</span>(x<span class="hljs-number">-1</span>, y);<br>        <span class="hljs-keyword">if</span>(!(f&gt;&gt;<span class="hljs-number">2</span>&amp;<span class="hljs-number">1</span>) &amp;&amp; <span class="hljs-built_in">check</span>(x, y<span class="hljs-number">+1</span>)) <span class="hljs-built_in">push</span>(x, y<span class="hljs-number">+1</span>);<br>        <span class="hljs-keyword">if</span>(!(f&gt;&gt;<span class="hljs-number">3</span>&amp;<span class="hljs-number">1</span>) &amp;&amp; <span class="hljs-built_in">check</span>(x<span class="hljs-number">+1</span>, y)) <span class="hljs-built_in">push</span>(x<span class="hljs-number">+1</span>, y);<br>    &#125;<br><br>    ans2=<span class="hljs-built_in">max</span>(ans2, sum);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)<br>            cin&gt;&gt;g[i][j];<br><br>    <span class="hljs-type">int</span> ans1=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)<br>            <span class="hljs-keyword">if</span>(!st[i][j])&#123;<br>                <span class="hljs-built_in">bfs</span>(i, j);<br>                ans1++;<br>            &#125;<br><br>    cout&lt;&lt;ans1&lt;&lt;endl;<br>    cout&lt;&lt;ans2&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="山峰和山谷"><a href="#山峰和山谷" class="headerlink" title="山峰和山谷"></a>山峰和山谷</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// http://ybt.ssoier.cn:8088/problem_show.php?pid=1454</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 判断联通块的性质</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1010</span>, M=N*N;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> w[N][N];<br><span class="hljs-type">int</span> st[N][N];<br>PII q[M];<br><span class="hljs-type">int</span> hh, tt;<br><span class="hljs-type">int</span> ans1, ans2;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> sx, <span class="hljs-type">int</span> sy)</span></span>&#123;<br>    hh=tt=<span class="hljs-number">0</span>;<br>    q[<span class="hljs-number">0</span>]=&#123;sx, sy&#125;;<br>    st[sx][sy]=<span class="hljs-literal">true</span>;<br><br>    <span class="hljs-type">int</span> height=w[sx][sy];<br>    <span class="hljs-type">bool</span> f1=<span class="hljs-literal">true</span>, f2=<span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">while</span>(hh&lt;=tt)&#123;<br>        <span class="hljs-keyword">auto</span> [x, y]=q[hh++];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x<span class="hljs-number">-1</span>;i&lt;=x<span class="hljs-number">+1</span>;i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=y<span class="hljs-number">-1</span>;j&lt;=y<span class="hljs-number">+1</span>;j++)&#123;<br>                <span class="hljs-keyword">if</span>(i==x &amp;&amp; j==y) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span> || i&gt;=n || j&lt;<span class="hljs-number">0</span> || j&gt;=n) <span class="hljs-keyword">continue</span>;<br><br>                <span class="hljs-comment">// 即使之前访问过也要判断周围高度</span><br>                <span class="hljs-keyword">if</span>(w[i][j]&gt;height) f1=<span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(w[i][j]&lt;height) f2=<span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">if</span>(st[i][j]) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">// 只有等高，要入队时才考虑有没有访问过</span><br>                    q[++tt]=&#123;i, j&#125;;<br>                    st[i][j]=<span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>    &#125;<br><br>    ans1+=f1, ans2+=f2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;w[i][j]);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>            <span class="hljs-keyword">if</span>(!st[i][j])&#123;<br>                <span class="hljs-built_in">bfs</span>(i, j);<br>            &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, ans1, ans2);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><h3 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// http://ybt.ssoier.cn:8088/problem_show.php?pid=1255</span><br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * BFS求最短路径</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1010</span>, M=N*N;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-type">bool</span> st[N][N];<br>PII q[M];<br>PII pre[N][N];<span class="hljs-comment">// 记录最短路径中当前点前一个坐标</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> sx, <span class="hljs-type">int</span> sy)</span></span>&#123;<br>    <span class="hljs-type">int</span> hh=<span class="hljs-number">0</span>, tt=<span class="hljs-number">0</span>;<br>    q[<span class="hljs-number">0</span>]=&#123;sx, sy&#125;;<br>    st[sx][sy]=<span class="hljs-literal">true</span>;<br><br>    <span class="hljs-built_in">memset</span>(pre, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> pre);<span class="hljs-comment">// 等于将每个pair的两个元素都赋值为-1</span><br>    <br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-keyword">while</span>(hh&lt;=tt)&#123;<br>        PII t=q[hh++];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>            <span class="hljs-type">int</span> x=t.x+dx[i], y=t.y+dy[i];<br><br>            <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span> || x&gt;=n || y&lt;<span class="hljs-number">0</span> || y&gt;=n) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(g[x][y]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(st[x][y]) <span class="hljs-keyword">continue</span>;<br><br>            q[++tt]=&#123;x, y&#125;;<br>            st[x][y]=<span class="hljs-literal">true</span>;<br><br>            pre[x][y]=t;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// scanf(&quot;%d&quot;, &amp;n);</span><br>    n=<span class="hljs-number">5</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;n; j++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;g[i][j]);<br><br>    <span class="hljs-built_in">bfs</span>(n<span class="hljs-number">-1</span>, n<span class="hljs-number">-1</span>);<br><br>    <span class="hljs-comment">// 回溯</span><br>    <span class="hljs-function">PII <span class="hljs-title">end</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d, %d)\n&quot;</span>, end.x, end.y);<br><br>        <span class="hljs-keyword">if</span>(end.x==n<span class="hljs-number">-1</span> &amp;&amp; end.y==n<span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;<br><br>        end=pre[end.x][end.y];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="武士风度的牛"><a href="#武士风度的牛" class="headerlink" title="武士风度的牛"></a>武士风度的牛</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://www.acwing.com/problem/content/190/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">200</span>, M=N*N;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">bool</span> st[N][N];<br>PII q[M];<br>PII pre[N][N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> sx, <span class="hljs-type">int</span> sy)</span></span>&#123;<br>    <span class="hljs-type">int</span> hh=<span class="hljs-number">0</span>, tt=<span class="hljs-number">0</span>;<br>    q[<span class="hljs-number">0</span>]=&#123;sx, sy&#125;;<br>    st[sx][sy]=<span class="hljs-literal">true</span>;<br><br>    <span class="hljs-built_in">memset</span>(pre, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> pre);<br><br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">8</span>]=&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-2</span>&#125;, dy[<span class="hljs-number">8</span>]=&#123;<span class="hljs-number">2</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;;<br><br>    <span class="hljs-keyword">while</span>(hh&lt;=tt)&#123;<br>        PII t=q[hh++];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)&#123;<br>            <span class="hljs-type">int</span> x=t.x+dx[i], y=t.y+dy[i];<br><br>            <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span> || x&gt;=n || y&lt;<span class="hljs-number">0</span> || y&gt;=m) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(st[x][y]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(g[x][y]==<span class="hljs-string">&#x27;*&#x27;</span>) <span class="hljs-keyword">continue</span>;<br><br>            q[++tt]=&#123;x, y&#125;;<br>            st[x][y]=<span class="hljs-literal">true</span>;<br><br>            pre[x][y]=t; <br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;m, &amp;n);<br><br>    <span class="hljs-type">int</span> x0, y0, x1, y1;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot; %c&quot;</span>, &amp;g[i][j]);<span class="hljs-comment">// &quot; %c&quot;：前面加一个空格，自动跳过换行符（空白符）</span><br>            <span class="hljs-keyword">if</span>(g[i][j]==<span class="hljs-string">&#x27;K&#x27;</span>) x0=i, y0=j;<br>            <span class="hljs-keyword">if</span>(g[i][j]==<span class="hljs-string">&#x27;H&#x27;</span>) x1=i, y1=j;<br>        &#125;<br><br>    <span class="hljs-built_in">bfs</span>(x1, y1);<br><br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-function">PII <span class="hljs-title">end</span><span class="hljs-params">(x0, y0)</span></span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        cnt++;<br>        <span class="hljs-keyword">if</span>(end.x==x1 &amp;&amp; end.y==y1) <span class="hljs-keyword">break</span>;<br>        end=pre[end.x][end.y];<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, cnt<span class="hljs-number">-1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="抓住那头牛"><a href="#抓住那头牛" class="headerlink" title="抓住那头牛"></a>抓住那头牛</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// http://ybt.ssoier.cn:8088/problem_show.php?pid=1253</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span><span class="hljs-number">+10</span>;<br><br><span class="hljs-type">int</span> n, k, l, r;<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-type">int</span> q[N];<br><span class="hljs-type">int</span> pre[N];<br><br><span class="hljs-type">int</span> hh=<span class="hljs-number">0</span>, tt=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ops</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> x0)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x&lt;l || x&gt;r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(st[x]) <span class="hljs-keyword">return</span>;<br><br>    q[++tt]=x;<br>    st[x]=<span class="hljs-literal">true</span>;<br><br>    pre[x]=x0;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> sx)</span></span>&#123;<br>    q[<span class="hljs-number">0</span>]=sx;<br>    st[sx]=<span class="hljs-literal">true</span>;<br><br>    <span class="hljs-built_in">memset</span>(pre, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> pre);<br><br>    <span class="hljs-keyword">while</span>(hh&lt;=tt)&#123;<br>        <span class="hljs-type">int</span> x0=q[hh++];<br><br>        <span class="hljs-built_in">ops</span>(x0<span class="hljs-number">+1</span>, x0);<br>        <span class="hljs-built_in">ops</span>(x0<span class="hljs-number">-1</span>, x0);<br>        <span class="hljs-built_in">ops</span>(<span class="hljs-number">2</span>*x0, x0);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);<br>    l=<span class="hljs-number">0</span>, r=N;<br><br>    <span class="hljs-built_in">bfs</span>(n);<br><br>    <span class="hljs-type">int</span> end=k, cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        cnt++;<br>        <span class="hljs-keyword">if</span>(end==n) <span class="hljs-keyword">break</span>;<br>        end=pre[end];<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, cnt<span class="hljs-number">-1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="跳房子（30分解答）"><a href="#跳房子（30分解答）" class="headerlink" title="跳房子（30分解答）"></a>跳房子（30分解答）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://sim.csp.thusaac.com/contest/36/problem/3</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+10</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> k[N];<br><br><span class="hljs-type">int</span> st[N];<br><span class="hljs-type">int</span> q[N];<br><span class="hljs-type">int</span> pre[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">skip</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span>&#123;<br>    <span class="hljs-comment">// 站在第i格向前跳j</span><br>    <span class="hljs-type">int</span> u=<span class="hljs-built_in">min</span>(i+j, n);<br>    <span class="hljs-keyword">return</span> u-a[u];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> sx)</span></span>&#123;<br>    <span class="hljs-type">int</span> hh=<span class="hljs-number">0</span>, tt=<span class="hljs-number">0</span>;<br>    q[<span class="hljs-number">0</span>]=sx;<br>    st[sx]=<span class="hljs-literal">true</span>;<br><br>    <span class="hljs-built_in">memset</span>(pre, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> pre);<br><br>    <span class="hljs-keyword">while</span>(hh&lt;=tt)&#123;<br>        <span class="hljs-type">int</span> x0=q[hh++];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k[x0];i++)&#123;<br>            <span class="hljs-type">int</span> x=<span class="hljs-built_in">skip</span>(x0, i);<br><br>            <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">1</span> || x&gt;n) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(st[x]) <span class="hljs-keyword">continue</span>;<br><br>            q[++tt]=x;<br>            st[x]=<span class="hljs-literal">true</span>;<br><br>            pre[x]=x0;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;k[i]);<br><br>    <span class="hljs-built_in">bfs</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;, pre[i]);</span><br>    <span class="hljs-comment">// printf(&quot;\n&quot;);</span><br><br>    <span class="hljs-type">int</span> end=n, cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        cnt++;<br><br>        <span class="hljs-keyword">if</span>(end==<span class="hljs-number">1</span>)<span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">if</span>(pre[end]==<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-number">-1</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        end=pre[end];<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, cnt<span class="hljs-number">-1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>寒假练题计划</category>
      
      <category>提高算法</category>
      
      <category>搜索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>algorithm</tag>
      
      <tag>ACwing</tag>
      
      <tag>BFS</tag>
      
      <tag>Flood-Fill</tag>
      
      <tag>Shortest-Path</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025-03-18[DP]状压DP</title>
    <link href="/2025/03/18/%E7%8A%B6%E5%8E%8BDP/"/>
    <url>/2025/03/18/%E7%8A%B6%E5%8E%8BDP/</url>
    
    <content type="html"><![CDATA[<h1 id="状压DP"><a href="#状压DP" class="headerlink" title="状压DP"></a>状压DP</h1><h2 id="状态压缩动态规划概述"><a href="#状态压缩动态规划概述" class="headerlink" title="状态压缩动态规划概述"></a>状态压缩动态规划概述</h2><ul><li><strong>定义</strong>：状态压缩动态规划是一种将问题的状态用二进制位表示，并通过位运算来高效处理状态转移的动态规划方法。它通常用于处理具有组合性质的优化问题，尤其适用于状态数量有限且可以通过位运算快速操作的场景。</li><li><strong>适用场景</strong>：<ul><li>问题的状态可以用二进制位表示，且状态数量相对较少（通常不超过 220）。</li><li>状态之间的转移关系可以通过位运算高效实现。</li><li>问题具有组合性质，需要考虑多种状态组合的最优解。</li></ul></li></ul><h2 id="状态压缩的基本概念"><a href="#状态压缩的基本概念" class="headerlink" title="状态压缩的基本概念"></a>状态压缩的基本概念</h2><ul><li><strong>状态表示</strong>：<ul><li>使用二进制位表示状态，每一位对应一个元素或一个位置的状态（如 0 表示未选择，1 表示已选择）。</li><li>例如，状态 <code>1011</code> 表示第 0、1、3 位被选择，第 2 位未被选择。</li></ul></li><li><strong>状态转移</strong>：<ul><li>通过位运算（如与、或、异或、左移、右移）实现状态之间的转换。</li><li>例如，<code>state &amp; (1 &lt;&lt; i)</code> 可以判断第 i 位是否为 1，<code>state | (1 &lt;&lt; i)</code> 可以将第 i 位设置为 1。</li></ul></li></ul><h2 id="状态压缩动态规划的步骤"><a href="#状态压缩动态规划的步骤" class="headerlink" title="状态压缩动态规划的步骤"></a>状态压缩动态规划的步骤</h2><ol><li><strong>定义状态</strong>：<ul><li>确定问题的状态表示方式，通常用一个整数表示一个状态，整数的每一位对应一个元素的状态。</li><li>例如，在棋盘问题中，状态可以表示为每一行的棋子分布情况。</li></ul></li><li><strong>初始化状态</strong>：<ul><li>确定初始状态的值，通常为 0 或其他特定值。</li><li>例如，<code>f[0][0] = 1</code> 表示初始状态的合法方案数为 1。</li></ul></li><li><strong>状态转移方程</strong>：<ul><li>根据问题的性质，设计状态转移方程，通过位运算实现状态之间的转换。</li><li>例如，在棋盘问题中，状态转移方程可以表示为 <code>f[i][j][a] += f[i-1][j-c][b]</code>，其中 <code>a</code> 和 <code>b</code> 是状态，<code>c</code> 是状态 <code>a</code> 中的棋子数量。</li></ul></li><li><strong>边界条件</strong>：<ul><li>确定状态的边界条件，避免非法状态的转移。</li><li>例如，在棋盘问题中，需要检查状态是否合法（如没有相邻的棋子）。</li></ul></li><li><strong>求解目标状态</strong>：<ul><li>根据问题的要求，求解目标状态的值。</li><li>例如，在棋盘问题中，目标状态是最后一行的合法方案数。</li></ul></li></ol><h2 id="状态压缩动态规划的优化技巧"><a href="#状态压缩动态规划的优化技巧" class="headerlink" title="状态压缩动态规划的优化技巧"></a>状态压缩动态规划的优化技巧</h2><ul><li><strong>滚动数组</strong>：<ul><li>使用滚动数组减少空间复杂度，只存储当前行和上一行的状态。</li><li>例如，在棋盘问题中，可以使用 <code>f[i&amp;1][j][a]</code> 来表示当前行的状态，<code>f[i-1&amp;1][j][a]</code> 来表示上一行的状态。</li></ul></li><li><strong>预处理合法状态</strong>：<ul><li>提前计算所有合法的状态，并存储在数组中，避免重复计算。</li><li>例如，在棋盘问题中，可以预先计算所有不包含相邻 1 的状态。</li></ul></li><li><strong>位运算优化</strong>：<ul><li>利用位运算的高效性，快速实现状态的判断和转换。</li><li>例如，<code>state &amp; (1 &lt;&lt; i)</code> 可以快速判断第 i 位的状态，<code>state | (1 &lt;&lt; i)</code> 可以快速设置第 i 位的状态。</li></ul></li></ul><h2 id="状态压缩动态规划的常见问题类型"><a href="#状态压缩动态规划的常见问题类型" class="headerlink" title="状态压缩动态规划的常见问题类型"></a>状态压缩动态规划的常见问题类型</h2><ul><li><strong>棋盘问题</strong>：<ul><li>在棋盘上放置棋子，要求满足某些条件（如没有相邻的棋子）。</li><li>例如，“小国王”问题和“炮兵阵地”问题。</li></ul></li><li><strong>组合优化问题</strong>：<ul><li>从一组元素中选择若干个元素，要求满足某些条件，并求最优解。</li><li>例如，“愤怒的小鸟”问题。</li></ul></li><li><strong>路径规划问题</strong>：<ul><li>在图中找到满足某些条件的路径。</li><li>例如，“玉米田”问题。</li></ul></li></ul><h2 id="状态压缩动态规划的复杂度分析"><a href="#状态压缩动态规划的复杂度分析" class="headerlink" title="状态压缩动态规划的复杂度分析"></a>状态压缩动态规划的复杂度分析</h2><ul><li><strong>时间复杂度</strong>：<ul><li>通常为 <em>O</em>(<em>n</em>×<em>m</em>×2<em>k</em>)，其中 <em>n</em> 和 <em>m</em> 是问题的规模，<em>k</em> 是状态的位数。</li><li>例如，在棋盘问题中，时间复杂度为 <em>O</em>(<em>n</em>×<em>m</em>×2<em>n</em>)。</li></ul></li><li><strong>空间复杂度</strong>：<ul><li>通常为 <em>O</em>(<em>m</em>×2<em>k</em>)，其中 <em>m</em> 是问题的规模，<em>k</em> 是状态的位数。</li><li>例如，在棋盘问题中，空间复杂度为 <em>O</em>(<em>m</em>×2<em>n</em>)。</li><li>通过滚动数组优化，可以将空间复杂度降低到 <em>O</em>(2<em>k</em>)。</li></ul></li></ul><h2 id="状态压缩动态规划的注意事项"><a href="#状态压缩动态规划的注意事项" class="headerlink" title="状态压缩动态规划的注意事项"></a>状态压缩动态规划的注意事项</h2><ul><li><strong>状态合法性检查</strong>：<ul><li>在状态转移过程中，需要确保所有参与转移的状态都是合法的。</li><li>例如，在棋盘问题中，需要检查状态是否包含相邻的 1。</li></ul></li><li><strong>状态转移顺序</strong>：<ul><li>确保状态转移的顺序正确，避免重复计算或遗漏某些状态。</li><li>例如，在棋盘问题中，需要按照从上到下的顺序逐行转移状态。</li></ul></li><li><strong>边界条件处理</strong>：<ul><li>注意处理边界条件，避免非法状态的转移。</li><li>例如，在棋盘问题中，需要处理最后一行的状态转移。</li></ul></li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="小国王"><a href="#小国王" class="headerlink" title="小国王"></a>小国王</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://www.cnblogs.com/littlehb/p/15752053.html</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基于连通性的状态压缩DP</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">15</span>, M=N*N, K=(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">10</span>)<span class="hljs-number">+10</span>;<br><br><span class="hljs-type">int</span> n, m;<br>vector&lt;<span class="hljs-type">int</span>&gt; state;<span class="hljs-comment">// 记录一行有多少种合法状态</span><br><span class="hljs-type">int</span> cnt[K];<br>vector&lt;<span class="hljs-type">int</span>&gt; head[K];<span class="hljs-comment">// 记录一种状态能转移到哪些状态</span><br>LL f[N][M][K];<span class="hljs-comment">// 只在前i行放棋子，放了j个棋子，第i行状态为s情况下的合法状态数</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> state)</span></span>&#123;<br>    <span class="hljs-comment">// 判断当前的状态是否不含相邻的1</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-keyword">if</span>((state&gt;&gt;i&amp;<span class="hljs-number">1</span>)&amp;&amp;(state&gt;&gt;i<span class="hljs-number">+1</span>&amp;<span class="hljs-number">1</span>))<span class="hljs-comment">// 错位相与</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-type">int</span> state)</span></span>&#123;<br>    <span class="hljs-comment">// 状态中有几个1</span><br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) res+=state&gt;&gt;i&amp;<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1</span>&lt;&lt;n;i++)<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(i))&#123;<br>            state.<span class="hljs-built_in">push_back</span>(i);<br>            cnt[i]=<span class="hljs-built_in">count</span>(i);<br>        &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;state.<span class="hljs-built_in">size</span>();i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;state.<span class="hljs-built_in">size</span>();j++)&#123;<br>            <span class="hljs-type">int</span> a=state[i], b=state[j];<br>            <span class="hljs-keyword">if</span>((a&amp;b)==<span class="hljs-number">0</span>&amp;&amp;<span class="hljs-built_in">check</span>(a|b))&#123;<br>                head[i].<span class="hljs-built_in">push_back</span>(j);<br>            &#125;<br>        &#125;<br><br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">+1</span>;i++)<span class="hljs-comment">// 多一行，&quot;n+1行&quot;用于统计结果</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;a&lt;state.<span class="hljs-built_in">size</span>();a++)<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> b:head[a])&#123;<br>                    <span class="hljs-type">int</span> c=cnt[state[a]];<br>                    <span class="hljs-keyword">if</span>(j&gt;=c)&#123;<br>                        f[i][j][a]+=f[i<span class="hljs-number">-1</span>][j-c][b];<br>                    &#125;<br>                &#125;<br><br>    cout&lt;&lt;f[n<span class="hljs-number">+1</span>][m][<span class="hljs-number">0</span>]&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="玉米田"><a href="#玉米田" class="headerlink" title="玉米田"></a>玉米田</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://www.acwing.com/problem/content/329/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD=<span class="hljs-number">1e8</span>, N=<span class="hljs-number">15</span>, M=<span class="hljs-number">15</span>, K=(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">12</span>)<span class="hljs-number">+10</span>;<br><br><span class="hljs-type">int</span> n, m;<span class="hljs-comment">// n行m列</span><br><span class="hljs-type">int</span> t[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; state;<br>vector&lt;<span class="hljs-type">int</span>&gt; head[K];<br><span class="hljs-type">int</span> f[N][K];<br><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> state)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>        <span class="hljs-keyword">if</span>((state&gt;&gt;i&amp;<span class="hljs-number">1</span>)&amp;&amp;(state&gt;&gt;i<span class="hljs-number">+1</span>&amp;<span class="hljs-number">1</span>))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;       <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            <span class="hljs-type">int</span> x;<br>            cin&gt;&gt;x;<br>            t[i]=t[i]&lt;&lt;<span class="hljs-number">1</span>|x;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1</span>&lt;&lt;m;i++)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(i))&#123;<br>            state.<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;state.<span class="hljs-built_in">size</span>();i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;state.<span class="hljs-built_in">size</span>();j++)&#123;<br>            <span class="hljs-type">int</span> a=state[i], b=state[j];<br>            <span class="hljs-keyword">if</span>((a&amp;b)==<span class="hljs-number">0</span>)<br>                head[i].<span class="hljs-built_in">push_back</span>(j);<br>        &#125;<br>            <br><br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">+1</span>;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;a&lt;state.<span class="hljs-built_in">size</span>();a++)<br>            <span class="hljs-keyword">if</span>((state[a]&amp;t[i])==state[a])<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> b:head[a])&#123;<br>                    f[i][a]+=f[i<span class="hljs-number">-1</span>][b];<br>                    f[i][a]%=MOD;<br>                &#125;<br><br>    cout&lt;&lt;f[n<span class="hljs-number">+1</span>][<span class="hljs-number">0</span>]&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="炮兵阵地"><a href="#炮兵阵地" class="headerlink" title="炮兵阵地"></a>炮兵阵地</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://www.acwing.com/problem/content/294/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">110</span>, M=<span class="hljs-number">15</span>, K=(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">10</span>)<span class="hljs-number">+10</span>;<br><br><span class="hljs-type">int</span> n, m;<br>vector&lt;<span class="hljs-type">int</span>&gt; state;<br><span class="hljs-type">int</span> cnt[K];<br>vector&lt;<span class="hljs-type">int</span>&gt; head[K];<br><span class="hljs-type">int</span> g[N];<br><span class="hljs-type">int</span> f[<span class="hljs-number">2</span>][K][K];<span class="hljs-comment">// 第i-1行状态是j，第i行状态是k, 改滚动数组</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> state)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>        <span class="hljs-keyword">if</span>((state&gt;&gt;i&amp;<span class="hljs-number">1</span>) &amp;&amp; ((state&gt;&gt;i<span class="hljs-number">+1</span>&amp;<span class="hljs-number">1</span>) || (state&gt;&gt;i<span class="hljs-number">+2</span>&amp;<span class="hljs-number">1</span>)))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-type">int</span> state)</span></span>&#123;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++) res+=state&gt;&gt;i&amp;<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            <span class="hljs-type">char</span> c;<br>            cin&gt;&gt;c;<br>            <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;H&#x27;</span>) g[i]+=<span class="hljs-number">1</span>&lt;&lt;j;<br>        &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1</span>&lt;&lt;m;i++)<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(i))&#123;<br>            state.<span class="hljs-built_in">push_back</span>(i);<br>            cnt[i]=<span class="hljs-built_in">count</span>(i);<br>        &#125;<br><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">+2</span>;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;state.<span class="hljs-built_in">size</span>();j++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;state.<span class="hljs-built_in">size</span>();k++)<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u=<span class="hljs-number">0</span>;u&lt;state.<span class="hljs-built_in">size</span>();u++)&#123;<br>                    <span class="hljs-type">int</span> a=state[j], b=state[k], c=state[u];<br>                    <span class="hljs-keyword">if</span>((a&amp;b)|(b&amp;c)|(a&amp;c)) <span class="hljs-keyword">continue</span>;<br>                    <span class="hljs-keyword">if</span>(g[i<span class="hljs-number">-1</span>]&amp;a|g[i]&amp;b) <span class="hljs-keyword">continue</span>;<br>                    f[i&amp;<span class="hljs-number">1</span>][j][k]=<span class="hljs-built_in">max</span>(f[i&amp;<span class="hljs-number">1</span>][j][k], f[i<span class="hljs-number">-1</span>&amp;<span class="hljs-number">1</span>][u][j]+cnt[b]);<br>                &#125;<br>                <br>    cout&lt;&lt;f[n<span class="hljs-number">+2</span>&amp;<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="愤怒的小鸟"><a href="#愤怒的小鸟" class="headerlink" title="愤怒的小鸟"></a>愤怒的小鸟</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://www.acwing.com/problem/content/526/</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 重复覆盖问题</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">double</span>, <span class="hljs-type">double</span>&gt; PDD;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">18</span>, M=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">18</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps=<span class="hljs-number">1e-6</span>;<br><br><span class="hljs-type">int</span> n, m;<br>PDD q[N];<br><span class="hljs-type">int</span> path[N][N];<br><span class="hljs-type">int</span> f[M];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span></span>&#123;<br>    <span class="hljs-comment">// 解决浮点数精度问题</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(x-y)&lt;eps) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(x&lt;y) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    cin&gt;&gt;T;<br><br>    <span class="hljs-keyword">while</span>(T--)&#123;<br>        cin&gt;&gt;n&gt;&gt;m;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;q[i].x&gt;&gt;q[i].y;<br><br>        <span class="hljs-comment">// 不在同一x坐标两点确定的抛物线上，各个点的情况（在抛物线上，或不在）</span><br>        <span class="hljs-built_in">memset</span>(path, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> path);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            path[i][i]=<span class="hljs-number">1</span>&lt;&lt;i;<span class="hljs-comment">// 约定一个点时只包含它自己</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(i==j) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-type">double</span> x1=q[i].x, x2=q[j].x;<br>                <span class="hljs-type">double</span> y1=q[i].y, y2=q[j].y;<br>                <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">cmp</span>(x1, x2)) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-type">double</span> a=(y1/x1-y2/x2)/(x1-x2);<br>                <span class="hljs-type">double</span> b=y1/x1-a*x1;<br>                <span class="hljs-keyword">if</span>(a&gt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-type">int</span> state=<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;n;k++)&#123;<br>                    <span class="hljs-type">double</span> x=q[k].x, y=q[k].y;<br>                    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">cmp</span>(a*x*x+b*x, y)) state+=<span class="hljs-number">1</span>&lt;&lt;k;<br>                &#125;<br>                path[i][j]=state;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> f);<br>        f[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1</span>&lt;&lt;n;i++)&#123;<br>            <span class="hljs-type">int</span> x=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>                <span class="hljs-keyword">if</span>(!(i&gt;&gt;j&amp;<span class="hljs-number">1</span>))&#123;<br>                    x=j;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>                f[i|path[x][j]]=<span class="hljs-built_in">min</span>(f[i|path[x][j]], f[i]<span class="hljs-number">+1</span>);<br>        &#125;<br><br>        cout&lt;&lt;f[(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>]&lt;&lt;endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>寒假练题计划</category>
      
      <category>提高算法</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>algorithm</tag>
      
      <tag>ACwing</tag>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025-03-17[DP]树形DP</title>
    <link href="/2025/03/17/%E6%A0%91%E5%BD%A2DP/"/>
    <url>/2025/03/17/%E6%A0%91%E5%BD%A2DP/</url>
    
    <content type="html"><![CDATA[<h1 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h1><h2 id="知识点介绍"><a href="#知识点介绍" class="headerlink" title="知识点介绍"></a>知识点介绍</h2><p>树形DP是一种基于树结构的动态规划算法。它利用树的递归性质，通过定义状态和状态转移方程来解决问题。树形DP的关键在于：</p><ol><li><strong>状态定义</strong>：根据问题的需求，定义每个节点的状态。状态可以是一个值，也可以是一个数组，用于存储与该节点相关的最优解信息。</li><li><strong>状态转移</strong>：通过子节点的状态来更新当前节点的状态。状态转移通常基于树的遍历顺序（如深度优先搜索DFS）进行。</li><li><strong>边界条件</strong>：明确叶子节点或特殊情况的状态值，作为递归的终止条件。</li></ol><p>树形DP适用于以下类型的问题：</p><ul><li>求树的最长路径（如树的直径）</li><li>求树的中心</li><li>求树上满足某些条件的最优解（如最小代价、最大收益等）</li></ul><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10010</span>, M = <span class="hljs-number">2</span> * N;<br><br><span class="hljs-type">int</span> n, h[N], e[M], ne[M], idx;<br><span class="hljs-type">int</span> f[N]; <span class="hljs-comment">// f[i] 表示以节点 i 为根的子树的最优解</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> father)</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化当前节点的状态</span><br>    f[u] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 遍历当前节点的所有子节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (j == father) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 跳过父节点</span><br><br>        <span class="hljs-built_in">dfs</span>(j, u); <span class="hljs-comment">// 递归处理子节点</span><br><br>        <span class="hljs-comment">// 根据子节点的状态更新当前节点的状态</span><br>        f[u] = <span class="hljs-built_in">max</span>(f[u], f[j] + ...); <span class="hljs-comment">// 根据具体问题修改状态转移方程</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br><br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-built_in">add</span>(a, b), <span class="hljs-built_in">add</span>(b, a);<br>    &#125;<br><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>); <span class="hljs-comment">// 从根节点开始DFS</span><br><br>    cout &lt;&lt; f[<span class="hljs-number">1</span>] &lt;&lt; endl; <span class="hljs-comment">// 输出根节点的最优解</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="树的最长路径"><a href="#树的最长路径" class="headerlink" title="树的最长路径"></a>树的最长路径</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://www.cnblogs.com/littlehb/p/15784687.html</span><br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 求树的直径</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * A. 经典方法</span><br><span class="hljs-comment"> * 1. 任取一点求距离该点最远的点u</span><br><span class="hljs-comment"> * 2. 再求距离该点最远的点v</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * B. 树形DP,如下做法</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">10010</span>, M=<span class="hljs-number">2</span>*N;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> h[N], e[M], ne[M], w[M], idx=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> ans;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span>&#123;<br>    e[idx]=b, w[idx]=c, ne[idx]=h[a], h[a]=idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> father)</span></span>&#123;<br>    <span class="hljs-type">int</span> dist=<span class="hljs-number">0</span>; <span class="hljs-comment">// 表示从当前点向下走的最大长度 </span><br>    <span class="hljs-type">int</span> d1=<span class="hljs-number">0</span>, d2=<span class="hljs-number">0</span>; <span class="hljs-comment">// 最大值和次大值,两者相加可以表示过当前结点的所有路径中最长的长度</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u];~i;i=ne[i])&#123;<br>        <span class="hljs-type">int</span> j=e[i];<br>        <span class="hljs-keyword">if</span>(j==father) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">// 如果遍历到父节点，直接跳过</span><br>        <span class="hljs-type">int</span> d=<span class="hljs-built_in">dfs</span>(j, u)+w[i];<br>        dist=<span class="hljs-built_in">max</span>(dist, d);<br><br>        <span class="hljs-keyword">if</span>(d&gt;=d1) d2=d1, d1=d;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d&gt;d2) d2=d;<br>    &#125;<br><br>    ans=<span class="hljs-built_in">max</span>(ans, d1+d2);<br><br>    <span class="hljs-keyword">return</span> dist;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br><br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        <span class="hljs-built_in">add</span>(a, b, c), <span class="hljs-built_in">add</span>(b, a, c);<span class="hljs-comment">// 无向边</span><br>    &#125;<br><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<span class="hljs-comment">// 任选一点开始dfs</span><br><br>    cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="树的中心"><a href="#树的中心" class="headerlink" title="树的中心"></a>树的中心</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://www.cnblogs.com/littlehb/p/15786805.html</span><br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 求所有点中，到其他点最远距离最小的点</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 第一遍dfs，求出每个点向下最大距离和次大距离</span><br><span class="hljs-comment"> * 第二遍dfs，求</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">10010</span>, M=<span class="hljs-number">2</span>*N, INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> h[N], e[M], ne[M], w[M], idx;<br><span class="hljs-type">int</span> d1[N], d2[N], p1[N], p2[N], up[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span>&#123;<br>    e[idx]=b, w[idx]=c, ne[idx]=h[a], h[a]=idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs_d</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> father)</span></span>&#123;<br>    d1[u]=d2[u]=-INF;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u];~i;i=ne[i])&#123;<br>        <span class="hljs-type">int</span> j=e[i];<br>        <span class="hljs-keyword">if</span>(j==father) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-type">int</span> d=<span class="hljs-built_in">dfs_d</span>(j, u)+w[i];<br>        <span class="hljs-keyword">if</span>(d&gt;=d1[u])&#123;<br>            d2[u]=d1[u], d1[u]=d;<br>            p2[u]=p1[u], p1[u]=j;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d&gt;d2[u]) d2[u]=d, p2[u]=j;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(d1[u]==-INF) d1[u]=d2[u]=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">return</span> d1[u];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs_u</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> father)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u];~i;i=ne[i])&#123;<br>        <span class="hljs-type">int</span> j=e[i];<br>        <span class="hljs-keyword">if</span>(j==father) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">if</span>(p1[u]==j) up[j]=<span class="hljs-built_in">max</span>(up[u], d2[u])+w[i];<br>        <span class="hljs-keyword">else</span> up[j]=<span class="hljs-built_in">max</span>(up[u], d1[u])+w[i];<br><br>        <span class="hljs-built_in">dfs_u</span>(j, u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        <span class="hljs-built_in">add</span>(a, b, c), <span class="hljs-built_in">add</span>(b, a, c);<br>    &#125;<br><br>    <span class="hljs-built_in">dfs_d</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>    <span class="hljs-built_in">dfs_u</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br><br>    <span class="hljs-type">int</span> res=INF;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) res=<span class="hljs-built_in">min</span>(res, <span class="hljs-built_in">max</span>(d1[i], up[i]));<br><br>    cout&lt;&lt;res&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数字转换"><a href="#数字转换" class="headerlink" title="数字转换"></a>数字转换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// http://ybt.ssoier.cn:8088/problem_show.php?pid=1577</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 可以变形成树的最大路径</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">50010</span>, M=<span class="hljs-number">2</span>*N;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> sum[N];<br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-type">int</span> ans;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br>    e[idx]=b, ne[idx]=h[a], h[a]=idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> father)</span></span>&#123;<br>    <span class="hljs-type">int</span> d1=<span class="hljs-number">0</span>, d2=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u];~i;i=ne[i])&#123;<br>        <span class="hljs-type">int</span> j=e[i];<br>        <span class="hljs-keyword">if</span>(j==father) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-type">int</span> d=<span class="hljs-built_in">dfs</span>(j, u)<span class="hljs-number">+1</span>;<br>        <span class="hljs-keyword">if</span>(d&gt;=d1) d2=d1, d1=d;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d&gt;d2) d2=d;<br>    &#125;<br><br>    ans=<span class="hljs-built_in">max</span>(ans, d1+d2);<br><br>    <span class="hljs-keyword">return</span> d1;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>;j&lt;=n/i;j++)<span class="hljs-comment">// j从2开始因为题目中说不包括数本身</span><br>            sum[i*j]+=i;<span class="hljs-comment">// 枚举i是哪些数的约数,sum从下标2开始有赋值</span><br><br>    <br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">if</span>(i&gt;sum[i])&#123;<br>            <span class="hljs-built_in">add</span>(sum[i], i);<br>            st[i]=<span class="hljs-literal">true</span>;<br>        &#125;<br><br>    <span class="hljs-comment">// 创建的是一颗森林</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">if</span>(!st[i]) <span class="hljs-built_in">dfs</span>(i, <span class="hljs-number">-1</span>);<br><br>    cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二叉苹果树"><a href="#二叉苹果树" class="headerlink" title="二叉苹果树"></a>二叉苹果树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// http://ybt.ssoier.cn:8088/problem_show.php?pid=1575</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 有依赖的背包问题的简化版</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">110</span>, M=<span class="hljs-number">2</span>*N;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> h[N], e[M], ne[M], w[M], idx;<br><span class="hljs-type">int</span> f[N][N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span>&#123;<br>    e[idx]=b, w[idx]=c, ne[idx]=h[a], h[a]=idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> father)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u];~i;i=ne[i])&#123;<br>        <span class="hljs-keyword">if</span>(e[i]==father) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-built_in">dfs</span>(e[i], u);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m;j&gt;=<span class="hljs-number">0</span>;j--)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;j;k++)<span class="hljs-comment">// 要留出1根，u结点和当前结点连接的树枝</span><br>                f[u][j]=<span class="hljs-built_in">max</span>(f[u][j], f[u][j-k<span class="hljs-number">-1</span>]+f[e[i]][k]+w[i]);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br><br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        <span class="hljs-built_in">add</span>(a, b, c), <span class="hljs-built_in">add</span>(b, a, c);<br>    &#125;<br><br>    <span class="hljs-comment">// 1号是根</span><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br><br>    cout&lt;&lt;f[<span class="hljs-number">1</span>][m]&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="战略游戏"><a href="#战略游戏" class="headerlink" title="战略游戏"></a>战略游戏</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// http://ybt.ssoier.cn:8088/problem_show.php?pid=1578</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1510</span>, M=<span class="hljs-number">2</span>*N;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;<br><span class="hljs-type">int</span> f[N][<span class="hljs-number">2</span>];<span class="hljs-comment">// 考虑以i为根子树，0表示i号不放士兵，1表示放</span><br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br>    e[idx]=b, ne[idx]=h[a], h[a]=idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> father)</span></span>&#123;<br>    f[u][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>, f[u][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u];~i;i=ne[i])&#123;<br>        <span class="hljs-type">int</span> j=e[i];<br>        <span class="hljs-keyword">if</span>(j==father) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs</span>(j, u);<br>        f[u][<span class="hljs-number">0</span>]+=f[j][<span class="hljs-number">1</span>];<br>        f[u][<span class="hljs-number">1</span>]+=<span class="hljs-built_in">min</span>(f[j][<span class="hljs-number">0</span>], f[j][<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br><br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> a, k;<br>        cin&gt;&gt;a&gt;&gt;k;<br>        <span class="hljs-keyword">while</span>(k--)&#123;<br>            <span class="hljs-type">int</span> b;<br>            cin&gt;&gt;b;<br>            <span class="hljs-built_in">add</span>(a, b), <span class="hljs-built_in">add</span>(b, a);<br>            st[b]=<span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> root;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-keyword">if</span>(!st[i])&#123;<br>            root=i;<br>            <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">-1</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>    <span class="hljs-comment">// cout&lt;&lt;root&lt;&lt;endl;</span><br>    cout&lt;&lt;<span class="hljs-built_in">min</span>(f[root][<span class="hljs-number">0</span>], f[root][<span class="hljs-number">1</span>])&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="皇宫看守"><a href="#皇宫看守" class="headerlink" title="皇宫看守"></a>皇宫看守</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// http://ybt.ssoier.cn:8088/problem_show.php?pid=1579</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1510</span>, M=<span class="hljs-number">2</span>*N, INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;<br><span class="hljs-type">int</span> cost[N];<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-type">int</span> f[N][<span class="hljs-number">3</span>];<span class="hljs-comment">// 0表示被没警卫且父节点看到， 1表示没警卫且被子节点看到， 2表示放了警卫</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br>    e[idx]=b, ne[idx]=h[a], h[a]=idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> father)</span></span>&#123;<br>    f[u][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>, f[u][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>, f[u][<span class="hljs-number">2</span>]=cost[u];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u]; ~i; i=ne[i])&#123;<br>        <span class="hljs-type">int</span> j=e[i];<br>        <span class="hljs-keyword">if</span>(j==father) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-built_in">dfs</span>(j, u);<br><br>        f[u][<span class="hljs-number">0</span>]+=<span class="hljs-built_in">min</span>(f[j][<span class="hljs-number">1</span>], f[j][<span class="hljs-number">2</span>]);<br>        f[u][<span class="hljs-number">2</span>]+=<span class="hljs-built_in">min</span>(f[j][<span class="hljs-number">0</span>], <span class="hljs-built_in">min</span>(f[j][<span class="hljs-number">1</span>], f[j][<span class="hljs-number">2</span>]));<br>    &#125;<br><br>    f[u][<span class="hljs-number">1</span>]=INF;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u]; ~i; i=ne[i])&#123;<br>        <span class="hljs-type">int</span> j=e[i];<br>        <span class="hljs-keyword">if</span>(j==father) <span class="hljs-keyword">continue</span>;<br><br>        f[u][<span class="hljs-number">1</span>]=<span class="hljs-built_in">min</span>(f[u][<span class="hljs-number">1</span>], f[j][<span class="hljs-number">2</span>]+f[u][<span class="hljs-number">0</span>]-<span class="hljs-built_in">min</span>(f[j][<span class="hljs-number">1</span>], f[j][<span class="hljs-number">2</span>]));<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br><br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>        <span class="hljs-type">int</span> a, m;<br>        cin&gt;&gt;a;<br>        cin&gt;&gt;cost[a]&gt;&gt;m;<br>        <span class="hljs-keyword">while</span>(m--)&#123;<br>            <span class="hljs-type">int</span> b;<br>            cin&gt;&gt;b;<br>            <span class="hljs-built_in">add</span>(a, b), <span class="hljs-built_in">add</span>(b, a);<br>            st[b]=<span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> root;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-keyword">if</span>(!st[i])&#123;<br>            root=i;<br>            <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">-1</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>    cout&lt;&lt;<span class="hljs-built_in">min</span>(f[root][<span class="hljs-number">1</span>], <span class="hljs-built_in">min</span>(f[root][<span class="hljs-number">0</span>], f[root][<span class="hljs-number">2</span>]))&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>寒假练题计划</category>
      
      <category>提高算法</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>algorithm</tag>
      
      <tag>ACwing</tag>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025-02-19[DP]数字三角形模型</title>
    <link href="/2025/02/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2%E6%A8%A1%E5%9E%8B/"/>
    <url>/2025/02/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划-数字三角形模型"><a href="#动态规划-数字三角形模型" class="headerlink" title="[动态规划]数字三角形模型"></a>[动态规划]数字三角形模型</h1><h2 id="1-动态规划分析方式—闫氏思考法"><a href="#1-动态规划分析方式—闫氏思考法" class="headerlink" title="1. 动态规划分析方式—闫氏思考法"></a>1. 动态规划分析方式—闫氏思考法</h2><p><img src="https://pic--oss.oss-cn-beijing.aliyuncs.com/img/QQ20250218-230126.png" alt="QQ20250218-230126"></p><ul><li>首先要设计一个状态表示的方法，体现在<code>dp</code>数组的设计，要求能够表示从开始到目标过程中所有用到的状态。</li><li>考虑状态的转移，实际上就是集合的划分，判断有几种情况能一步转移到当前的状态，集合划分的标准：<code>不重复，不遗漏</code>，这里有个技巧，一般看能一步到到<code>最后一步</code>的状态划分。</li></ul><h2 id="2-数字三角型模型"><a href="#2-数字三角型模型" class="headerlink" title="2. 数字三角型模型"></a>2. 数字三角型模型</h2><ul><li>网格，从左上到右下，只能单向走（不能回头），求累积的最大值&#x2F;最小值</li></ul><h2 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3. 注意事项"></a>3. 注意事项</h2><ul><li>一般下标从1开始，因为涉及“i-1”操作，方便初始化。</li><li>当求最大值时，0行和0列就初始化成0，可以不动。</li><li>当求最小值时，就要具体分析，也可以直接做特判，不用0行和0列。</li></ul><h2 id="4-例题"><a href="#4-例题" class="headerlink" title="4.例题"></a>4.例题</h2><p><img src="https://pic--oss.oss-cn-beijing.aliyuncs.com/img/QQ20250219-165549.png" alt="QQ20250219-165549"></p><h3 id="4-1-数字三角形"><a href="#4-1-数字三角形" class="headerlink" title="4.1 数字三角形"></a>4.1 数字三角形</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://www.luogu.com.cn/problem/P1216</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> a[N][N];<br><span class="hljs-type">int</span> dp[N][N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>            cin&gt;&gt;a[i][j];<br>            dp[i][j]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+a[i][j], dp[i<span class="hljs-number">-1</span>][j]+a[i][j]);<br>        &#125;<br><br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) res=<span class="hljs-built_in">max</span>(res, dp[n][i]);<br><br>    cout&lt;&lt;res&lt;&lt;endl;    <br><br>&#125;<br>        <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-摘花生"><a href="#4-2-摘花生" class="headerlink" title="4.2 摘花生"></a>4.2 摘花生</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://www.acwing.com/file_system/file/content/whole/index/content/4183962/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><br><span class="hljs-type">int</span> a[N][N];<br><span class="hljs-type">int</span> dp[N][N];<br><br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-type">int</span> t;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; t;<br><br>    <span class="hljs-keyword">while</span>(t--)&#123;<br>        cin &gt;&gt; n &gt;&gt; m;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>                cin&gt;&gt;a[i][j];<br>                dp[i][j]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j]+a[i][j], dp[i][j<span class="hljs-number">-1</span>]+a[i][j]);<br>            &#125;<br>                <br>        cout&lt;&lt;dp[n][m]&lt;&lt;endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-最低通行费"><a href="#4-2-最低通行费" class="headerlink" title="4.2 最低通行费"></a>4.2 最低通行费</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// http://ybt.ssoier.cn:8088/problem_show.php?pid=1287</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 花费时间不超过2n-1说明不能走回头路， 所以类似于摘花生</span><br><span class="hljs-comment"> * 但值得注意的是，</span><br><span class="hljs-comment"> * 摘花生求的是最大和，所以可以把0行和0列上的a值看做0；</span><br><span class="hljs-comment"> * 这里是求最小和，所以还是要特判</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>, INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-type">int</span> a[N][N];<br><span class="hljs-type">int</span> dp[N][N];<br><br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    m=n;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            cin&gt;&gt;a[i][j];<br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>&amp;j==<span class="hljs-number">1</span>) dp[i][j]=a[i][j];<br>            <span class="hljs-keyword">else</span>&#123;<br>                dp[i][j]=INF;<br>                <span class="hljs-keyword">if</span>(i<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">1</span>) dp[i][j]=<span class="hljs-built_in">min</span>(dp[i][j], dp[i<span class="hljs-number">-1</span>][j]+a[i][j]);<br>                <span class="hljs-keyword">if</span>(j<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">1</span>) dp[i][j]=<span class="hljs-built_in">min</span>(dp[i][j], dp[i][j<span class="hljs-number">-1</span>]+a[i][j]);<br>            &#125;<br>        &#125;<br>            <br>    cout&lt;&lt;dp[n][m]&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-方格取数"><a href="#4-3-方格取数" class="headerlink" title="4.3 方格取数"></a>4.3 方格取数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// http://ybt.ssoier.cn:8088/problem_show.php?pid=1277</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 题意：从左上走到右下，走两次，但是同一个格子中的数只能取一次</span><br><span class="hljs-comment"> * 初步dp设想：dp[i1][j1][i2][j2]表示从分别从(1, 1) (1, 1)走到(i1, j1) (i2, j2)的和</span><br><span class="hljs-comment"> * 重要性质：考虑到每次每步只能走一格，而且终点坐标一样都是(n, n)，所以两次每步走过的格子满足i1+j1==i2+j2</span><br><span class="hljs-comment"> * 令i1+j1=i2+j2=k</span><br><span class="hljs-comment"> * 压缩状态：dp[k][i1][i2]</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 集合划分：</span><br><span class="hljs-comment"> * i1-1 j1   i2-1 j2   -&gt; k-1 i1-1 i2-1</span><br><span class="hljs-comment"> * i1   j1-1 i2   j2-1 -&gt; k-1 i1   i2</span><br><span class="hljs-comment"> * i1-1 j1   i2   j2-1 -&gt; k-1 i1-1 i2</span><br><span class="hljs-comment"> * i1   j1-1 i2-1 j2   -&gt; k-1 i1   i2-1</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 然后考虑加上两次的当前格</span><br><span class="hljs-comment"> * 如果i1==i2说明重合，只加一格的值</span><br><span class="hljs-comment"> * 否则分别加上(i1, k-i1) (i2, k-i2)的值</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">15</span>;<br><br><span class="hljs-type">int</span> w[N][N];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">2</span>*N][N][N];<br><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> a, b, c;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c, a||b||c) w[a][b]=c;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">2</span>;k&lt;=<span class="hljs-number">2</span>*n;k++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i1=<span class="hljs-number">1</span>;i1&lt;=n;i1++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i2=<span class="hljs-number">1</span>;i2&lt;=n;i2++)&#123;<br>                <span class="hljs-type">int</span> j1=k-i1, j2=k-i2;<br>                <span class="hljs-comment">//判断坐标合法</span><br>                <span class="hljs-keyword">if</span>(j1&gt;=<span class="hljs-number">1</span>&amp;&amp;j1&lt;=n&amp;&amp;j2&gt;=<span class="hljs-number">1</span>&amp;&amp;j2&lt;=n)&#123;<br>                    <span class="hljs-type">int</span> t=w[i1][k-i1];<br>                    <span class="hljs-keyword">if</span>(i2!=i1) t+=w[i2][k-i2];<br>                    <span class="hljs-type">int</span> &amp;x=dp[k][i1][i2];<br>                    x=<span class="hljs-built_in">max</span>(x, dp[k<span class="hljs-number">-1</span>][i1][i2]+t);<br>                    x=<span class="hljs-built_in">max</span>(x, dp[k<span class="hljs-number">-1</span>][i1<span class="hljs-number">-1</span>][i2]+t);<br>                    x=<span class="hljs-built_in">max</span>(x, dp[k<span class="hljs-number">-1</span>][i1][i2<span class="hljs-number">-1</span>]+t);<br>                    x=<span class="hljs-built_in">max</span>(x, dp[k<span class="hljs-number">-1</span>][i1<span class="hljs-number">-1</span>][i2<span class="hljs-number">-1</span>]+t);<br>                &#125;<br>            &#125;<br><br>    cout&lt;&lt;dp[<span class="hljs-number">2</span>*n][n][n]&lt;&lt;endl;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>寒假练题计划</category>
      
      <category>提高算法</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>algorithm</tag>
      
      <tag>ACwing</tag>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025-02-15[线段树]区间修改</title>
    <link href="/2025/02/15/%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%88%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%EF%BC%89/"/>
    <url>/2025/02/15/%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%88%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="线段树（区间修改）"><a href="#线段树（区间修改）" class="headerlink" title="线段树（区间修改）"></a>线段树（区间修改）</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><h3 id="区间修改与懒标记"><a href="#区间修改与懒标记" class="headerlink" title="区间修改与懒标记"></a>区间修改与懒标记</h3><p><img src="https://pic--oss.oss-cn-beijing.aliyuncs.com/img/58f1b460284997ca4f693f193d9a10e.png" alt="58f1b460284997ca4f693f193d9a10e"></p><p>线段树是一种高效的数据结构，用于处理区间查询和修改操作。当涉及到区间修改时，懒标记（Lazy Propagation）是一种重要的优化手段，可以避免每次修改都直接更新所有节点，从而提高效率。懒标记的基本思想是将修改操作延迟到必要时才进行。</p><p>以下是懒标记的实现要点：</p><ol><li><strong>标记存储</strong>：在每个节点中存储懒标记，表示当前节点的区间需要进行的修改操作。</li><li><strong>标记下推</strong>：在访问子节点之前，将当前节点的懒标记下推到子节点。</li><li><strong>标记清除</strong>：在将懒标记下推后，清除当前节点的懒标记。</li><li><strong>标记累积</strong>：如果当前节点已经有懒标记，新的修改操作需要与旧的懒标记进行累积。</li></ol><h3 id="扫描线算法"><a href="#扫描线算法" class="headerlink" title="扫描线算法"></a>扫描线算法</h3><p><img src="https://pic--oss.oss-cn-beijing.aliyuncs.com/img/9f19f143acc5942712d0b66e133629e.png" alt="9f19f143acc5942712d0b66e133629e"></p><p>扫描线算法是一种用于处理几何问题（如矩形面积并、线段覆盖等）的算法。其基本思想是将问题分解为一系列事件（如线段的起点和终点），并按照某种顺序（通常是横坐标）处理这些事件。</p><p>以下是扫描线算法的实现要点：</p><ol><li><strong>事件排序</strong>：将所有事件按照横坐标排序。</li><li><strong>线段树维护</strong>：使用线段树维护当前扫描线的覆盖状态。</li><li><strong>离散化</strong>：对于浮点数坐标，需要进行离散化处理。</li><li><strong>动态更新</strong>：在扫描过程中，动态更新线段树的状态，并计算结果。</li></ol><p><strong>注意</strong>：</p><ol><li>扫描线 算法解决覆盖区间求并的问题</li><li>以x轴作为扫描的方向（要将线段按x大小排序），我们要计算的是扫过的面积，所以<code>不包含第一条线</code> </li><li>线段树的<code>端点</code>是y方向上的<code>区间</code>（因为要维护长度!）， 映射<code>tr[i].l ... tr[i].r</code>对应<code>ys[tr[i].l-1] ... ys[tr[i].r-1+1]</code></li><li>由于y值可能为浮点数，所以需要离散化</li><li>要维护的属性有<code>cnt</code>，入边<code>+1</code>， 出边<code>-1</code>；还有<code>len</code>，保存的是区间内的<code>覆盖长度</code></li><li>这里虽然要对区间进行修改，但是我们每次查询只针对<code>根节点</code>，即<code>tr[1]</code>，所以只要在modify及时pushup，就不需要pushdown操作</li><li>扫描线虽然用到了线段树，但比较反常，所以背过是最好的方式-_-||</li></ol><h3 id="多个懒标记的累积"><a href="#多个懒标记的累积" class="headerlink" title="多个懒标记的累积"></a>多个懒标记的累积</h3><p>当线段树中存在多个懒标记时，需要正确处理它们的累积。例如，在区间加法和乘法的组合操作中，需要先处理乘法标记，再处理加法标记。累积公式如下：</p><ul><li><strong>乘法标记累积</strong>：<code>mul_new = mul * mul&#39;</code></li><li><strong>加法标记累积</strong>：<code>add_new = add * mul&#39; + add&#39;</code></li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="一个简单的整数问题2"><a href="#一个简单的整数问题2" class="headerlink" title="一个简单的整数问题2"></a>一个简单的整数问题2</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://www.luogu.com.cn/problem/U250323</span><br><br><span class="hljs-comment">/* 经典区间修改，单点查询，需要懒标记*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+10</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> l, r;<br>    ll sum;<br>    <span class="hljs-type">int</span> add;<br>&#125;tr[<span class="hljs-number">4</span>*N];<br><br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    tr[u].sum=tr[u&lt;&lt;<span class="hljs-number">1</span>].sum+tr[u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向所有的子树进行 传播，但不修改 自己</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">auto</span> &amp;root=tr[u], &amp;left=tr[u&lt;&lt;<span class="hljs-number">1</span>], &amp;right=tr[u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">if</span>(root.add)&#123;<br>        left.add+=root.add, left.sum+=(ll)(left.r-left.l<span class="hljs-number">+1</span>)*root.add;<span class="hljs-comment">//注意左右子树可能已经被标记，需要累加</span><br>        right.add+=root.add, right.sum+=(ll)(right.r-right.l<span class="hljs-number">+1</span>)*root.add;<br>        root.add=<span class="hljs-number">0</span>;<span class="hljs-comment">//消除懒标记</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    tr[u]=&#123;l, r&#125;;<br><br>    <span class="hljs-keyword">if</span>(l==r)&#123;<br>        tr[u].sum=a[l];<br>        <span class="hljs-keyword">return</span>;<br>    &#125; <br><br>    <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(u&lt;&lt;<span class="hljs-number">1</span>, l, mid), <span class="hljs-built_in">build</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>, mid<span class="hljs-number">+1</span>, r);<br>    <span class="hljs-built_in">pushup</span>(u);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> add)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)&#123;<br>        tr[u].sum+=(ll)(tr[u].r-tr[u].l<span class="hljs-number">+1</span>)*add;<br>        tr[u].add+=add;<span class="hljs-comment">//懒标记， 同样是要累加，不能直接赋值=</span><br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    <span class="hljs-built_in">pushdown</span>(u);<br><br>    <span class="hljs-type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(l&lt;=mid) <span class="hljs-built_in">modify</span>(u&lt;&lt;<span class="hljs-number">1</span>, l, r, add);<br>    <span class="hljs-keyword">if</span>(r&gt;mid) <span class="hljs-built_in">modify</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>, l, r, add);<br><br>    <span class="hljs-built_in">pushup</span>(u);<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br><br>    <span class="hljs-keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r) <span class="hljs-keyword">return</span> tr[u].sum;<br><br>    <span class="hljs-built_in">pushdown</span>(u);<br><br>    ll res=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(l&lt;=mid) res+=<span class="hljs-built_in">query</span>(u&lt;&lt;<span class="hljs-number">1</span>, l, r);<br>    <span class="hljs-keyword">if</span>(r&gt;mid) res+=<span class="hljs-built_in">query</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>, l ,r);<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br><br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br><br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">char</span> op[<span class="hljs-number">2</span>];<br><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, op);<br><br>        <span class="hljs-keyword">if</span>(*op==<span class="hljs-string">&#x27;C&#x27;</span>)&#123;<br>            <span class="hljs-type">int</span> l, r, d;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;d);<br><br>            <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, l, r, d);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">int</span> l ,r;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);<br><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, l, r));<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="亚特兰蒂斯"><a href="#亚特兰蒂斯" class="headerlink" title="亚特兰蒂斯"></a>亚特兰蒂斯</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://www.acwing.com/problem/content/249/</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1. 扫描线 算法解决覆盖区间求并的问题</span><br><span class="hljs-comment"> * 2. 以x轴作为扫描的方向（要将线段按x大小排序），我们要计算的是扫过的面积，所以不包含第一条线 </span><br><span class="hljs-comment"> * 3. 线段树的端点是y方向上的区间（因为要维护长度!）， 映射tr[i].l ... tr[i].r对应ys[tr[i].l-1] ... ys[tr[i].r-1+1]</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> *        1    2   3   4   ...   </span><br><span class="hljs-comment"> *           1   2   3  ...        </span><br><span class="hljs-comment"> * 4. 由于y值可能为浮点数，所以需要离散化</span><br><span class="hljs-comment"> * 5. 要维护的属性有cnt，入边+1， 出边-1；还有len，保存的是区间内的覆盖长度</span><br><span class="hljs-comment"> * 6. 这里虽然要对区间进行修改，但是我们每次查询只针对根节点，即tr[1]，所以只要在modify及时pushup就可以，不需要pushdown操作</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 总结：扫描线虽然用到了线段树，但比较反常，所以背过是最好的方式-_-||</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">//review</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">10010</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Segment</span>&#123;<br>    <span class="hljs-type">double</span> x, y1, y2;<br>    <span class="hljs-type">int</span> k;<span class="hljs-comment">//入边+1，出边-1</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Segment&amp; t)<span class="hljs-type">const</span>&#123;<br>        <span class="hljs-keyword">return</span> x&lt;t.x;<br>    &#125;<br>&#125;seg[<span class="hljs-number">2</span>*N];<span class="hljs-comment">//一个矩形有两条扫描线</span><br><br>vector&lt;<span class="hljs-type">double</span>&gt; ys;<span class="hljs-comment">//离散化y坐标</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>, r=ys.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>        <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(ys[mid]&gt;=x) r=mid;<span class="hljs-comment">//[l, mid]</span><br>        <span class="hljs-keyword">else</span> l=mid<span class="hljs-number">+1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l<span class="hljs-number">+1</span>; <span class="hljs-comment">// 下标从1开始</span><br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> l, r;<br>    <span class="hljs-type">int</span> cnt;<br>    <span class="hljs-type">double</span> len;<br>&#125;tr[<span class="hljs-number">2</span>*N*<span class="hljs-number">4</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tr[u].cnt) tr[u].len=ys[(tr[u].r<span class="hljs-number">-1</span>)<span class="hljs-number">+1</span>]-ys[tr[u].l<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tr[u].l!=tr[u].r) tr[u].len=tr[u&lt;&lt;<span class="hljs-number">1</span>].len+tr[u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].len;<br>    <span class="hljs-keyword">else</span> tr[u].len=<span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    tr[u]=&#123;l, r, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">if</span>(l!=r)&#123;<br>        <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">build</span>(u&lt;&lt;<span class="hljs-number">1</span>, l, mid), <span class="hljs-built_in">build</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>, mid<span class="hljs-number">+1</span>, r);<br>        <span class="hljs-comment">//pushup(u);</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> d)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r) &#123;<br>        tr[u].cnt+=d;<br>        <span class="hljs-built_in">pushup</span>(u);<span class="hljs-comment">//要及时pushup，因为没有用专门的函数去执行query操作</span><br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    <span class="hljs-type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(l&lt;=mid) <span class="hljs-built_in">modify</span>(u&lt;&lt;<span class="hljs-number">1</span>, l, r, d);<br>    <span class="hljs-keyword">if</span>(r&gt;mid) <span class="hljs-built_in">modify</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>, l, r, d);<br><br>    <span class="hljs-built_in">pushup</span>(u);<br>&#125;<br><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> t=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n), n)&#123;<span class="hljs-comment">//n=0退出</span><br>        <span class="hljs-comment">//多条测试样例时，每次都要记得初始化操作！！！</span><br>        ys.<span class="hljs-built_in">clear</span>();<span class="hljs-comment">//清空ys</span><br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Test case #%d\n&quot;</span>, t++);<br><br>        <span class="hljs-type">int</span> idx=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-type">double</span> x1, y1, x2, y2;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf%lf%lf%lf&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);<br><br>            ys.<span class="hljs-built_in">push_back</span>(y1), ys.<span class="hljs-built_in">push_back</span>(y2);<br><br>            seg[idx++]=&#123;x1, y1, y2, <span class="hljs-number">1</span>&#125;, seg[idx++]=&#123;x2, y1, y2, <span class="hljs-number">-1</span>&#125;;<br>        &#125;<br><br>        <span class="hljs-built_in">sort</span>(ys.<span class="hljs-built_in">begin</span>(), ys.<span class="hljs-built_in">end</span>());<br>        ys.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(ys.<span class="hljs-built_in">begin</span>(), ys.<span class="hljs-built_in">end</span>()), ys.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-built_in">sort</span>(seg, seg<span class="hljs-number">+2</span>*n);<br><br>        <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, ys.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<span class="hljs-comment">//m个端点，m-1条线段</span><br><br>        <span class="hljs-type">double</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>*n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">0</span>) res+=tr[<span class="hljs-number">1</span>].len*(seg[i].x-seg[i<span class="hljs-number">-1</span>].x);<span class="hljs-comment">//起点线不需要</span><br>            <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">find</span>(seg[i].y1), <span class="hljs-built_in">find</span>(seg[i].y2)<span class="hljs-number">-1</span>, seg[i].k);<br>        &#125;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Total explored area: %.2lf\n\n&quot;</span>, res);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="维护序列"><a href="#维护序列" class="headerlink" title="维护序列"></a>维护序列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// http://ybt.ssoier.cn:8088/problem_show.php?pid=1551</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 修改区间的方式有两种，所以我们需要考虑顺序问题，先乘后加可以维持懒标记的格式</span><br><span class="hljs-comment"> * (sum * mul + add) * mul&#x27; + add&#x27; = sum * mul * mul&#x27; + add * mul&#x27; + add&#x27;</span><br><span class="hljs-comment"> * 得到累积懒标记:</span><br><span class="hljs-comment"> * mul_new = mul * mul&#x27;</span><br><span class="hljs-comment"> * add_new = add * mul&#x27; + add&#x27; </span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">int</span> n, p, m;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+10</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> l, r;<br>    ll sum;<br><br>    ll add, mul;<br><br>    <span class="hljs-built_in">Node</span>()&#123;add=<span class="hljs-number">0</span>, mul=<span class="hljs-number">1</span>;&#125;<br>&#125;tr[<span class="hljs-number">4</span>*N];<br><br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    tr[u].sum=(tr[u&lt;&lt;<span class="hljs-number">1</span>].sum+tr[u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum)%p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lazy</span><span class="hljs-params">(Node&amp; t, ll add, ll mul)</span></span>&#123;<br>    t.sum=(t.sum*mul+add*(t.r-t.l<span class="hljs-number">+1</span>))%p;<span class="hljs-comment">//只应用当前的修改</span><br><br>    <span class="hljs-comment">//累积修改</span><br>    t.mul=(t.mul*mul)%p; <br>    t.add=(t.add*mul+add)%p; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <span class="hljs-keyword">auto</span> &amp;root=tr[u], &amp;left=tr[u&lt;&lt;<span class="hljs-number">1</span>], &amp;right=tr[u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> mul=root.mul, add=root.add;<br><br>    <span class="hljs-keyword">if</span>(!(root.add==<span class="hljs-number">0</span>&amp;&amp;root.mul==<span class="hljs-number">1</span>))&#123;<br>        <span class="hljs-built_in">lazy</span>(left, add, mul);<br>        <span class="hljs-built_in">lazy</span>(right, add, mul);<br>        root.add=<span class="hljs-number">0</span>, root.mul=<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    tr[u].l=l, tr[u].r=r;<br>    <br>    <span class="hljs-keyword">if</span>(l==r)&#123;<br>        tr[u].sum=a[l];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(u&lt;&lt;<span class="hljs-number">1</span>, l, mid), <span class="hljs-built_in">build</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>, mid<span class="hljs-number">+1</span>, r);<br><br>    <span class="hljs-built_in">pushup</span>(u);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> add, <span class="hljs-type">int</span> mul)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)&#123;<br>        <span class="hljs-built_in">lazy</span>(tr[u], add, mul);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    <span class="hljs-built_in">pushdown</span>(u);<br><br>    <span class="hljs-type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(l&lt;=mid) <span class="hljs-built_in">modify</span>(u&lt;&lt;<span class="hljs-number">1</span>, l, r, add, mul);<br>    <span class="hljs-keyword">if</span>(r&gt;mid) <span class="hljs-built_in">modify</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>, l, r, add, mul);<br><br>    <span class="hljs-built_in">pushup</span>(u);<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r) <span class="hljs-keyword">return</span> tr[u].sum%p;<br><br>    <span class="hljs-built_in">pushdown</span>(u);<br><br>    <span class="hljs-type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="hljs-number">1</span>;<br>    ll res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(l&lt;=mid) res+=<span class="hljs-built_in">query</span>(u&lt;&lt;<span class="hljs-number">1</span>, l, r);<br>    <span class="hljs-keyword">if</span>(r&gt;mid) res+=<span class="hljs-built_in">query</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>, l, r);<br><br>    <span class="hljs-keyword">return</span> res%p;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;p);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br><br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;m);<br><br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> op, l, r;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;op, &amp;l, &amp;r);<br><br>        <span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-type">int</span> c;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;c);<br>            <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, l, r, <span class="hljs-number">0</span>, c);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-type">int</span> c;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;c);<br>            <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, l, r, c, <span class="hljs-number">1</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, l, r));<br>        &#125;  <br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>寒假练题计划</category>
      
      <category>提高算法</category>
      
      <category>数据结构</category>
      
      <category>线段树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>algorithm</tag>
      
      <tag>ACwing</tag>
      
      <tag>segment tree</tag>
      
      <tag>Scan line</tag>
      
      <tag>lazy tag</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025-02-12[线段树]单点修改</title>
    <link href="/2025/02/12/%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%88%E5%8D%95%E7%82%B9%E4%BF%AE%E6%94%B9%EF%BC%89/"/>
    <url>/2025/02/12/%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%88%E5%8D%95%E7%82%B9%E4%BF%AE%E6%94%B9%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="线段树-单点修改"><a href="#线段树-单点修改" class="headerlink" title="线段树(单点修改)"></a>线段树(单点修改)</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p><img src="https://pic--oss.oss-cn-beijing.aliyuncs.com/img/b907982af472b92e58493a275858e38.png" alt="b907982af472b92e58493a275858e38"></p><ul><li>注意：若只涉及到单点修改，则不需要pushdown（懒加载）操作。</li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="最大数"><a href="#最大数" class="headerlink" title="最大数"></a>最大数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// http://ybt.ssoier.cn:8088/problem_show.php?pid=1549</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 单点修改， (没涉及到区间修改，所以不需要懒标记pushdown操作)</span><br><span class="hljs-comment"> * 区间查询</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M=<span class="hljs-number">2e5</span><span class="hljs-number">+10</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> l, r;<br>    <span class="hljs-type">int</span> v;<br>&#125;tr[<span class="hljs-number">4</span>*M];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    tr[u].v=<span class="hljs-built_in">max</span>(tr[u&lt;&lt;<span class="hljs-number">1</span>].v, tr[u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].v);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    tr[u]=&#123;l, r&#125;;<br>    <span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(u&lt;&lt;<span class="hljs-number">1</span>, l, mid), <span class="hljs-built_in">build</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>, mid<span class="hljs-number">+1</span>, r);<br>    <span class="hljs-built_in">pushup</span>(u);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r) <span class="hljs-keyword">return</span> tr[u].v;<br><br>    <span class="hljs-type">int</span> v=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(l&lt;=mid) v=<span class="hljs-built_in">query</span>(u&lt;&lt;<span class="hljs-number">1</span>, l, r);<br>    <span class="hljs-keyword">if</span>(r&gt;mid) v=<span class="hljs-built_in">max</span>(v, <span class="hljs-built_in">query</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>, l, r));<br><br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tr[u].l==x&amp;&amp;tr[u].r==x)&#123;<br>        tr[u].v=v;<br>        <span class="hljs-keyword">return</span>;<br>    &#125; <br><br>    <span class="hljs-type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(x&lt;=mid) <span class="hljs-built_in">modify</span>(u&lt;&lt;<span class="hljs-number">1</span>, x, v);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>, x, v);<br>    <span class="hljs-built_in">pushup</span>(u);<br>&#125;<br><br><span class="hljs-type">int</span> m, p, a=<span class="hljs-number">0</span>, n=<span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;m, &amp;p);<br><br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, m);<br><br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">char</span> op[<span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span> x;<br><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%d&quot;</span>, op, &amp;x);<br><br>        <span class="hljs-keyword">if</span>(*op==<span class="hljs-string">&#x27;Q&#x27;</span>)&#123;<br>            a=<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, n-x<span class="hljs-number">+1</span>, n);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            n++;<br>            <span class="hljs-type">int</span> v=(a+x)%p;<br>            <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, n, v);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="你能回答这些问题吗"><a href="#你能回答这些问题吗" class="headerlink" title="你能回答这些问题吗"></a>你能回答这些问题吗</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://www.acwing.com/problem/content/246/</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 依旧是单点修改，</span><br><span class="hljs-comment"> * 区间查询</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 但是涉及的到维护多个值</span><br><span class="hljs-comment"> * 针对一个区间u，左半区间l，右半区间r</span><br><span class="hljs-comment"> * 要求的连续最大连续子段和有三种情况</span><br><span class="hljs-comment"> * 其中两种是等于左半区间或右半区间的最大子段和</span><br><span class="hljs-comment"> * 剩下只可能横跨两个区间，</span><br><span class="hljs-comment"> * 此时最大连续子段和等于左半的最大靠右连续子段和加上右半最大靠左连续子段和</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span><span class="hljs-number">+10</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> l, r;<br>    <span class="hljs-type">int</span> v, sum, lv, rv;<br>&#125;tr[<span class="hljs-number">4</span>*N];<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(Node&amp; u, Node&amp; l, Node&amp; r)</span></span>&#123;<br>    <span class="hljs-comment">//更新单独封装出一个函数，可以复用</span><br>    u.sum=l.sum+r.sum;<br>    u.lv=<span class="hljs-built_in">max</span>(l.lv, l.sum+r.lv);<br>    u.rv=<span class="hljs-built_in">max</span>(r.rv, r.sum+l.rv);<br>    u.v=<span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(l.v, r.v), l.rv+r.lv);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <span class="hljs-built_in">pushup</span>(tr[u], tr[u&lt;&lt;<span class="hljs-number">1</span>], tr[u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    tr[u].l=l, tr[u].r=r;<br><br>    <span class="hljs-keyword">if</span>(l==r)&#123;<br>        tr[u].sum=tr[u].lv=tr[u].rv=tr[u].v=a[l];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(u&lt;&lt;<span class="hljs-number">1</span>, l, mid), <span class="hljs-built_in">build</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>, mid<span class="hljs-number">+1</span>, r);<br>    <span class="hljs-built_in">pushup</span>(u);<br>&#125;<br><br><span class="hljs-function">Node <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r) <span class="hljs-keyword">return</span> tr[u];<br><br>    <span class="hljs-type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(r&lt;=mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(u&lt;&lt;<span class="hljs-number">1</span>, l, r);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l&gt;mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>, l, r);<br>    <span class="hljs-keyword">else</span>&#123;<br>        Node res=<span class="hljs-built_in">Node</span>(), lres=<span class="hljs-built_in">query</span>(u&lt;&lt;<span class="hljs-number">1</span>, l, r), rres=<span class="hljs-built_in">query</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>, l, r);<br>        <span class="hljs-built_in">pushup</span>(res, lres, rres);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tr[u].l==x&amp;&amp;tr[u].r==x) &#123;<br>        tr[u].sum = tr[u].lv = tr[u].rv = tr[u].v = v;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(x&lt;=mid) <span class="hljs-built_in">modify</span>(u&lt;&lt;<span class="hljs-number">1</span>, x, v);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>, x, v);<br><br>    <span class="hljs-built_in">pushup</span>(u);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br><br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br><br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> k, x, y;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;k, &amp;x, &amp;y);<br><br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-type">int</span> tmp=<span class="hljs-built_in">max</span>(x, y);<br>            x=<span class="hljs-built_in">min</span>(x, y);<br>            y=tmp;<br>            Node res=<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, x, y);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res.v);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, x, y);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="区间最大公约数"><a href="#区间最大公约数" class="headerlink" title="区间最大公约数"></a>区间最大公约数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://www.acwing.com/problem/content/description/247/</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 本题表面上是区间更新</span><br><span class="hljs-comment"> * 实际上如果直接维护a数组，区间每个元素都加上d，根本无法维护gcd</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 这里要使用到gcd的性质：</span><br><span class="hljs-comment"> * res=gcd(a[l], a[l+1], a[l+2], ..., a[r]) = gcd(a[l], a[l+1]-a[l], a[l+2]-a[l+1], ..., a[r]-a[r-1])</span><br><span class="hljs-comment"> * (线性变换不改变gcd)</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 进一步地， res=gcd(a[l], gcd(diff[l+1], diff[l+2], ..., diff[r]))</span><br><span class="hljs-comment"> * 所以用线段树维护差分数组，就可以把区间更新变成单点更新</span><br><span class="hljs-comment"> * 维护区间gcd, 还有区间和sum</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-function">ll <span class="hljs-title">gcd</span><span class="hljs-params">(ll a, ll b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> __gcd(a, b);<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span><span class="hljs-number">+10</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> l, r;<br>    ll sum, gcd;<br>&#125;tr[<span class="hljs-number">4</span>*N];<br><br>ll a[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    tr[u].sum=tr[u&lt;&lt;<span class="hljs-number">1</span>].sum+tr[u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum;<br>    tr[u].gcd=<span class="hljs-built_in">gcd</span>(tr[u&lt;&lt;<span class="hljs-number">1</span>].gcd, tr[u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].gcd);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    tr[u]=&#123;l, r&#125;;<br><br>    <span class="hljs-keyword">if</span>(l==r)&#123;<br>        tr[u].sum=tr[u].gcd=a[l]-a[l<span class="hljs-number">-1</span>];<span class="hljs-comment">//a的差分</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(u&lt;&lt;<span class="hljs-number">1</span>, l, mid), <span class="hljs-built_in">build</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>, mid<span class="hljs-number">+1</span>, r);<br><br>    <span class="hljs-built_in">pushup</span>(u);<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">query_sum</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r) <span class="hljs-keyword">return</span> tr[u].sum;<br><br>    <span class="hljs-type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="hljs-number">1</span>;<br>    ll res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(l&lt;=mid) res+=<span class="hljs-built_in">query_sum</span>(u&lt;&lt;<span class="hljs-number">1</span>, l, r);<br>    <span class="hljs-keyword">if</span>(r&gt;mid) res+=<span class="hljs-built_in">query_sum</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>, l, r);<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">query_gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r) <span class="hljs-keyword">return</span> tr[u].gcd;<br><br>    <span class="hljs-type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(r&lt;=mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query_gcd</span>(u&lt;&lt;<span class="hljs-number">1</span>, l, r);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l&gt;mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query_gcd</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>, l, r);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">gcd</span>(<span class="hljs-built_in">query_gcd</span>(u&lt;&lt;<span class="hljs-number">1</span>, l, r), <span class="hljs-built_in">query_gcd</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>, l, r));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> x, ll add)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tr[u].l==x&amp;&amp;tr[u].r==x)&#123;<br>        tr[u].sum+=add;<br>        tr[u].gcd+=add;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(x&lt;=mid) <span class="hljs-built_in">modify</span>(u&lt;&lt;<span class="hljs-number">1</span>, x, add);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>, x, add);<br><br>    <span class="hljs-built_in">pushup</span>(u);<br>&#125;<br><br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;a[i]);<br>    a[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br><br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">char</span> op[<span class="hljs-number">2</span>];<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, op);<br><br>        <span class="hljs-keyword">if</span>(*op==<span class="hljs-string">&#x27;C&#x27;</span>)&#123;<br>            <span class="hljs-type">int</span> l, r;<br>            ll d;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%lld&quot;</span>, &amp;l, &amp;r, &amp;d);<br><br>            <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, l, d);<br>            <span class="hljs-keyword">if</span>(r<span class="hljs-number">+1</span>&lt;=n) <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, r<span class="hljs-number">+1</span>, -d);<span class="hljs-comment">//差分在n+1处减没有实际意义，而且会导致越界！！！</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">int</span> l, r;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);<br><br>            ll x=<span class="hljs-built_in">query_sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, l);<br>            ll y;<br>            <span class="hljs-keyword">if</span>(l<span class="hljs-number">+1</span>&lt;=r) y=<span class="hljs-built_in">query_gcd</span>(<span class="hljs-number">1</span>, l<span class="hljs-number">+1</span>, r);<span class="hljs-comment">//一定要保证区间是合法的！！！</span><br>            <span class="hljs-keyword">else</span> y=x;<span class="hljs-comment">//当区间只有一个元素时，根本就没有后面的差分</span><br><br>            ll res=<span class="hljs-built_in">gcd</span>(x, y);<br><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-built_in">abs</span>(res));<span class="hljs-comment">//差分可能有负数</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-comment">// printf(&quot;%lld&quot;, gcd(1, 2));</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>寒假练题计划</category>
      
      <category>提高算法</category>
      
      <category>数据结构</category>
      
      <category>线段树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>algorithm</tag>
      
      <tag>ACwing</tag>
      
      <tag>binary search</tag>
      
      <tag>segment tree</tag>
      
      <tag>gcd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025-02-09最小生成树的扩展应用</title>
    <link href="/2025/02/09/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E6%89%A9%E5%B1%95%E5%BA%94%E7%94%A8/"/>
    <url>/2025/02/09/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E6%89%A9%E5%B1%95%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="最小生成树的扩展应用"><a href="#最小生成树的扩展应用" class="headerlink" title="最小生成树的扩展应用"></a>最小生成树的扩展应用</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><h3 id="最小生成树相关知识点"><a href="#最小生成树相关知识点" class="headerlink" title="最小生成树相关知识点"></a>最小生成树相关知识点</h3><ul><li><strong>定义与性质</strong><ul><li>最小生成树是指在一个加权连通图里，找到一棵生成树，其所有边的权值之和最小。</li><li>最小生成树的边数等于顶点数减1。</li><li>最小生成树不唯一，但其边权之和唯一。</li></ul></li><li><strong>Kruskal算法</strong><ul><li><strong>基本思想</strong>：按照边权从小到大的顺序选择边，每次选择的边不会与已选择的边构成环，直到选择n-1条边为止。</li><li><strong>实现步骤</strong>：<ol><li>对所有边按照权值从小到大排序。</li><li>初始化并查集，每个顶点自成一个集合。</li><li>遍历排序后的边，对于每条边，如果它的两个端点属于不同的集合，则将这条边加入最小生成树，并合并这两个集合。</li><li>重复上一步，直到选择n-1条边或所有顶点都在同一个集合中。</li></ol></li><li><strong>适用场景</strong>：适用于边数较多的稀疏图。</li><li><strong>时间复杂度</strong>：主要取决于排序的复杂度，为O(ElogE)，其中E为边数。</li></ul></li><li><strong>并查集</strong><ul><li><strong>基本操作</strong><ul><li><strong>查找</strong>：确定元素所属集合的代表元素（根节点），路径压缩可以优化查找效率，使每次查找的时间复杂度接近O(1)。</li><li><strong>合并</strong>：将两个元素所在的集合合并为一个集合，按秩合并可以避免树过高，保证操作效率。</li></ul></li><li><strong>在最小生成树中的作用</strong>：用于判断两个顶点是否在同一棵树（集合）中，从而判断加入一条边是否会形成环。</li><li><strong>维护集合大小</strong>：每个集合的大小的可维护的。</li></ul></li></ul><h3 id="例题中的扩展应用知识点"><a href="#例题中的扩展应用知识点" class="headerlink" title="例题中的扩展应用知识点"></a>例题中的扩展应用知识点</h3><ul><li><strong>添加虚拟节点</strong><ul><li>在“新的开始”例题中，引入“超级发电站”作为虚拟节点，将建立发电站的问题转化为从该虚拟节点引出线路的问题，从而将问题转化为最小生成树问题。这种方法可以将一些特殊约束条件转化为图论模型中的常规元素，方便利用最小生成树算法求解。</li></ul></li><li><strong>结合其他约束条件</strong><ul><li><strong>北极通讯网络</strong>：考虑了卫星电话数量的限制，将部分边用卫星通话代替，从而优化了最小生成树的构建过程。这体现了在实际问题中，最小生成树问题可能需要结合其他条件进行调整和优化，以满足特定需求。</li><li><strong>秘密的牛奶运输</strong>：涉及到次小生成树的求解，包括严格次小生成树和非严格次小生成树的概念及求解方法。这说明在一些问题中，除了最小生成树本身，还需要考虑与最小生成树相近的其他生成树，以应对不同的问题要求。</li></ul></li><li><strong>维护额外信息</strong><ul><li><strong>走廊泼水节</strong>：在构建最小生成树的过程中，需要维护并查集的大小，通过size数组记录每个集合的大小，以便在计算结果时考虑集合大小对最终答案的影响。这表明在某些情况下，除了基本的最小生成树结构，还需要额外维护一些信息，以满足问题的特殊要求。</li></ul></li><li><strong>路径上最大边的维护</strong><ul><li>在“秘密的牛奶运输”中，通过DFS或LCA等方法维护最小生成树中两点路径上的最大边权值，以便在求次小生成树时进行权值的更新和比较。这体现了在一些复杂问题中，需要对最小生成树的结构进行更深入的分析和处理，以获取更详细的信息用于进一步的计算。</li></ul></li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="新的开始"><a href="#新的开始" class="headerlink" title="新的开始"></a>新的开始</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// http://ybt.ssoier.cn:8088/problem_show.php?pid=1488</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 假想在某处建立发电站等于从“超级发电站”引出一条线路到该点，路径花费为发电站造价</span><br><span class="hljs-comment"> * 把所有假想路径也加进去，就变成了典型的最小生成树问题！</span><br><span class="hljs-comment"> * 这里至少要有一个地方要建发电站，所以“超级发电站”一定要包括在内</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">310</span>, M=N*N+N<span class="hljs-number">+10</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>    <span class="hljs-type">int</span> a, b, w;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Edge&amp; t)<span class="hljs-type">const</span>&#123;<br>        <span class="hljs-keyword">return</span> w&lt;t.w;<br>    &#125;<br>&#125;e[M];<br><span class="hljs-type">int</span> p[N];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x]!=x) p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++) p[i]=i;<br><br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-type">int</span> w;<br>        cin&gt;&gt;w;<br>        e[cnt++]=&#123;<span class="hljs-number">0</span>, i, w&#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-type">int</span> w;<br>            cin&gt;&gt;w;<br>            <span class="hljs-keyword">if</span>(i&lt;j)&#123;<br>                e[cnt++]=&#123;i, j, w&#125;;<br>            &#125;<br>        &#125;  <br><br>    <span class="hljs-built_in">sort</span>(e, e+cnt);<br><br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;cnt;i++)&#123;<br>        <span class="hljs-type">int</span> a=<span class="hljs-built_in">find</span>(e[i].a), b=<span class="hljs-built_in">find</span>(e[i].b), w=e[i].w;<br>        <span class="hljs-keyword">if</span>(a!=b)&#123;<br>            res+=w;<br>            p[a]=b;<br>        &#125;<br>    &#125;<br><br>    cout&lt;&lt;res&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="北极通讯网络"><a href="#北极通讯网络" class="headerlink" title="北极通讯网络"></a>北极通讯网络</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// http://ybt.ssoier.cn:8088/problem_show.php?pid=1487</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, k;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">510</span>, M=N*N<span class="hljs-number">+10</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>    <span class="hljs-type">int</span> a, b;<br>    <span class="hljs-type">float</span> w;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Edge&amp;t)<span class="hljs-type">const</span>&#123;<br>        <span class="hljs-keyword">return</span> w&lt;t.w;<br>    &#125;<br>&#125;e[M];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>&#123;<br>    <span class="hljs-type">float</span> x, y;<br>&#125;a[N];<br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">dis</span><span class="hljs-params">(Point&amp; p1, Point&amp; p2)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>((p<span class="hljs-number">1.</span>x-p<span class="hljs-number">2.</span>x)*(p<span class="hljs-number">1.</span>x-p<span class="hljs-number">2.</span>x)+(p<span class="hljs-number">1.</span>y-p<span class="hljs-number">2.</span>y)*(p<span class="hljs-number">1.</span>y-p<span class="hljs-number">2.</span>y));<br>&#125;<br><br><span class="hljs-type">int</span> p[N];<br><br><span class="hljs-type">float</span> res[N];<br><span class="hljs-type">int</span> idx=<span class="hljs-number">0</span>;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x]!=x) p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);<br>    k--;<span class="hljs-comment">//k个卫星电话可以代替k-1条线路</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) p[i]=i;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%f%f&quot;</span>, &amp;a[i].x, &amp;a[i].y);<br>    &#125;<br><br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(i&lt;j)&#123;<br>                e[cnt++]=&#123;i, j, <span class="hljs-built_in">dis</span>(a[i], a[j])&#125;;<br>            &#125;<br>        &#125;<br><br>    <span class="hljs-built_in">sort</span>(e, e+cnt);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;cnt;i++)&#123;<br>        <span class="hljs-type">int</span> a=<span class="hljs-built_in">find</span>(e[i].a), b=<span class="hljs-built_in">find</span>(e[i].b);<br>        <span class="hljs-type">float</span> w=e[i].w;<br>        <span class="hljs-keyword">if</span>(a!=b)&#123;<br>            p[a]=b;<br>            res[idx++]=w;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(idx&lt;=k) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf\n&quot;</span>, <span class="hljs-number">0.00</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf\n&quot;</span>, res[idx-k<span class="hljs-number">-1</span>]);<span class="hljs-comment">//最大的若干条边用卫星通话代替</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="走廊泼水节"><a href="#走廊泼水节" class="headerlink" title="走廊泼水节"></a>走廊泼水节</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://www.luogu.com.cn/problem/P10928</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 从小到大遍历最小生成树的每一条边&#123;a, b, w&#125;，</span><br><span class="hljs-comment"> * 合并两端点a, b各自所在的联通块，两个联通块各取一点组合连接，考虑最小生成树唯一，边权w+1</span><br><span class="hljs-comment"> * 减去a, b连接的那条边 </span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 这里要维护并查集的大小，用size数组，size[i]表示i所在集合大小</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">6010</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>    <span class="hljs-type">int</span> a, b, w;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Edge&amp;t)<span class="hljs-type">const</span>&#123;<br>        <span class="hljs-keyword">return</span> w&lt;t.w;<br>    &#125;<br>&#125;e[N];<br><span class="hljs-type">int</span> p[N], size[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x]!=x) p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> t;<br>    cin&gt;&gt;t;<br><br>    <span class="hljs-keyword">while</span>(t--)&#123;<br>        cin&gt;&gt;n;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            p[i]=i;<br>            size[i]=<span class="hljs-number">1</span>;<br>        &#125; <br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>            <span class="hljs-type">int</span> a, b, w;<br>            cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;<br>            e[i]=&#123;a, b, w&#125;;<br>        &#125;<br><br>        <span class="hljs-built_in">sort</span>(e, e+n<span class="hljs-number">-1</span>);<br><br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>            <span class="hljs-type">int</span> a=<span class="hljs-built_in">find</span>(e[i].a), b=<span class="hljs-built_in">find</span>(e[i].b), w=e[i].w;<br>            <span class="hljs-keyword">if</span>(a!=b)&#123;<br>                res+=(size[a]*size[b]<span class="hljs-number">-1</span>)*(w<span class="hljs-number">+1</span>);<br>                size[b]+=size[a];<span class="hljs-comment">//只维护父节点</span><br>                p[a]=b;<br>            &#125;<br>        &#125;<br><br>        cout&lt;&lt;res&lt;&lt;endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="秘密的牛奶运输"><a href="#秘密的牛奶运输" class="headerlink" title="秘密的牛奶运输"></a>秘密的牛奶运输</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// http://ybt.ssoier.cn:8088/problem_show.php?pid=1490</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 次小生成树有两种，严格和非严格的，非严格的可以允许权重之和等于最小生成树的</span><br><span class="hljs-comment"> * 解决次小生成树有两种方法</span><br><span class="hljs-comment"> * 第一种：求出最小生成树后，枚举删除其一条边，再求剩余图的最小生成树，维护最小权重和，只能解决非严格</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 第二种（比较常用）：枚举非最小生成树边添加到最小生成树中，再删除最小生成树的一条边，维护最小权重和</span><br><span class="hljs-comment"> * 记sum为最小生成树的权重之和，枚举到非树边&#123;a, b, w&#125;，dist[a][b]为最小生成树中a到b路径上最大边</span><br><span class="hljs-comment"> * new_sum=sum+w-dist[a][b]</span><br><span class="hljs-comment"> * 注意，在求严格次小生成树时，要确保new_sum严格大于sum，也就是w要严格大于dist[a][b]，才更新最值</span><br><span class="hljs-comment"> * 有关dist数组的维护，比较好的做法是用lca，这里用粗糙的dfs求出也能勉强通过</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2010</span>, M=<span class="hljs-number">20010</span>;<br><span class="hljs-type">const</span> ll INF=<span class="hljs-number">1e18</span>;<br><br><span class="hljs-comment">//Kruskal</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>    <span class="hljs-type">int</span> a, b;<br>    ll w;<br>    <span class="hljs-type">bool</span> f;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Edge&amp;t)<span class="hljs-type">const</span>&#123;<br>        <span class="hljs-keyword">return</span> w&lt;t.w;<br>    &#125;<br>&#125;edge[M];<br><span class="hljs-type">int</span> p[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x]!=x) p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">//邻接表</span><br><span class="hljs-type">int</span> h[N], e[<span class="hljs-number">2</span>*M], ne[<span class="hljs-number">2</span>*M], idx;<br>ll w[<span class="hljs-number">2</span>*M];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, ll c)</span></span>&#123;<br>    e[idx]=b, w[idx]=c, ne[idx]=h[a], h[a]=idx++;<br>&#125;<br><br><span class="hljs-comment">//维护路径上最大边</span><br>ll dist[N][N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa, ll maxd, ll d[])</span></span>&#123;<br>    d[u]=maxd;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u];~i;i=ne[i])&#123;<br>        <span class="hljs-type">int</span> j=e[i];<br>        <span class="hljs-keyword">if</span>(j!=fa)&#123;<br>            <span class="hljs-built_in">dfs</span>(j, u, <span class="hljs-built_in">max</span>(w[i], maxd), d);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) p[i]=i;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> a, b;<br>        ll c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%lld&quot;</span>, &amp;a, &amp;b, &amp;c);<br>        edge[i]=&#123;a, b, c, <span class="hljs-literal">false</span>&#125;;<br>    &#125;<br><br>    <span class="hljs-built_in">sort</span>(edge, edge+m);<br><br>    ll sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> a=<span class="hljs-built_in">find</span>(edge[i].a), b=<span class="hljs-built_in">find</span>(edge[i].b);<br>        ll c=edge[i].w;<br>        <span class="hljs-keyword">if</span>(a!=b)&#123;<br>            p[a]=b;<br>            sum+=c;<br>            <span class="hljs-built_in">add</span>(edge[i].a, edge[i].b, c), <span class="hljs-built_in">add</span>(edge[i].b, edge[i].a, c);<br>            edge[i].f=<span class="hljs-literal">true</span>;<span class="hljs-comment">//标记这条边在最小生成树上</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//计算dist</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">dfs</span>(i, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, dist[i]);<br><br>    ll res=INF;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!edge[i].f)&#123;<br>            <span class="hljs-type">int</span> a=edge[i].a, b=edge[i].b;<br>            ll c=edge[i].w;<br>            <span class="hljs-keyword">if</span>(c&gt;dist[a][b]) res=<span class="hljs-built_in">min</span>(res, sum+c-dist[a][b]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, res);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>寒假练题计划</category>
      
      <category>提高算法</category>
      
      <category>图论</category>
      
      <category>最小生成树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>algorithm</tag>
      
      <tag>ACwing</tag>
      
      <tag>DFS</tag>
      
      <tag>MST</tag>
      
      <tag>Kruskal</tag>
      
      <tag>Prim</tag>
      
      <tag>Disjoint-set</tag>
      
      <tag>LCA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025-02-06最小生成树的典型应用</title>
    <link href="/2025/02/06/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8/"/>
    <url>/2025/02/06/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="最小生成树的典型应用"><a href="#最小生成树的典型应用" class="headerlink" title="最小生成树的典型应用"></a>最小生成树的典型应用</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><h3 id="1-最小生成树的基本概念"><a href="#1-最小生成树的基本概念" class="headerlink" title="1. 最小生成树的基本概念"></a>1. <strong>最小生成树的基本概念</strong></h3><ul><li><strong>定义</strong>：在一个加权连通图中，最小生成树是一个包含图中所有顶点的子图，且边的总权重最小。</li><li><strong>应用场景</strong>：网络设计、城市规划、通信线路铺设等，目标是连接所有节点，同时最小化总成本。</li><li><strong>一般思路</strong>：</li></ul><p><img src="https://pic--oss.oss-cn-beijing.aliyuncs.com/img/b8ca4fd7d9a88ad3c59f2eb2a85ee2f.png" alt="b8ca4fd7d9a88ad3c59f2eb2a85ee2f"></p><h3 id="2-最小生成树的两种主要算法"><a href="#2-最小生成树的两种主要算法" class="headerlink" title="2. 最小生成树的两种主要算法"></a>2. <strong>最小生成树的两种主要算法</strong></h3><ul><li><p><strong>Prim算法</strong></p><ul><li><p><strong>适用场景</strong>：适用于稠密图（边数较多的图）。</p></li><li><p><strong>时间复杂度</strong>：O(n2)，可以通过堆优化降低到 O(mlogn)。</p></li><li><p><strong>核心思想</strong>：从一个起点开始，逐步扩展最小生成树，每次选择与当前生成树相连的最小权重边。</p></li><li><p><strong>代码实现</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j])) t = j;<br>        &#125;<br><br>        res += dist[t];<br>        st[t] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) dist[j] = <span class="hljs-built_in">min</span>(dist[j], w[t][j]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>Kruskal算法</strong></p><ul><li><p><strong>适用场景</strong>：适用于稀疏图（边数较少的图）。</p></li><li><p><strong>时间复杂度</strong>：O(mlogm)，其中 m 是边的数量。</p></li><li><p><strong>核心思想</strong>：将所有边按权重从小到大排序，依次选择不形成环的边加入最小生成树。</p></li><li><p><strong>代码实现</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) p[i] = i;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> a, b, w;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;<br>        e[i] = &#123;a, b, w&#125;;<br>    &#125;<br><br>    <span class="hljs-built_in">sort</span>(e, e + m);<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> a = <span class="hljs-built_in">find</span>(e[i].a), b = <span class="hljs-built_in">find</span>(e[i].b), w = e[i].w;<br>        <span class="hljs-keyword">if</span> (a != b) &#123;<br>            p[a] = b;<br>            res += w;<br>        &#125;<br>    &#125;<br><br>    cout &lt;&lt; res &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-并查集的使用"><a href="#3-并查集的使用" class="headerlink" title="3. 并查集的使用"></a>3. <strong>并查集的使用</strong></h3><ul><li><p><strong>功能</strong>：用于管理不相交集合，支持快速合并和查找操作。</p></li><li><p><strong>核心操作</strong>：</p><ul><li><strong>查找操作（Find）</strong>：通过路径压缩优化查找效率。</li><li><strong>合并操作（Union）</strong>：通过按秩合并优化合并效率。</li></ul></li><li><p><strong>代码实现</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">union_sets</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-type">int</span> rootA = <span class="hljs-built_in">find</span>(a), rootB = <span class="hljs-built_in">find</span>(b);<br>    <span class="hljs-keyword">if</span> (rootA != rootB) &#123;<br>        p[rootA] = rootB;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-最小生成树的变种问题"><a href="#4-最小生成树的变种问题" class="headerlink" title="4. 最小生成树的变种问题"></a>4. <strong>最小生成树的变种问题</strong></h3><ul><li><p><strong>最大边权最小化</strong>：</p><ul><li><p><strong>问题描述</strong>：在维持连通性的情况下，使最大边权最小。</p></li><li><p><strong>解决方案</strong>：使用Kruskal算法，记录最后加入的边的权重。</p></li><li><p><strong>代码实现</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> max = <span class="hljs-number">-1</span>, s = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-built_in">find</span>(e[i].a), b = <span class="hljs-built_in">find</span>(e[i].b), w = e[i].w;<br>    <span class="hljs-keyword">if</span> (a != b) &#123;<br>        p[a] = b;<br>        s++;<br>        max = w;<br>    &#125;<br>&#125;<br><br>cout &lt;&lt; s &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; max &lt;&lt; endl;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>必选边和可选边</strong>：</p><ul><li><p><strong>问题描述</strong>：某些边必须选择，某些边可以选择。</p></li><li><p><strong>解决方案</strong>：先处理必选边，再处理可选边。</p></li><li><p><strong>代码实现</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>    <span class="hljs-type">int</span> f, a, b, w;<br>    cin &gt;&gt; f &gt;&gt; a &gt;&gt; b &gt;&gt; w;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> aa = <span class="hljs-built_in">find</span>(a), bb = <span class="hljs-built_in">find</span>(b);<br>        <span class="hljs-keyword">if</span> (aa != bb) p[aa] = bb;<br>        res += w;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        e[cnt++] = &#123;a, b, w&#125;;<br>    &#125;<br>&#125;<br><br><span class="hljs-built_in">sort</span>(e, e + cnt);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i++) &#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-built_in">find</span>(e[i].a), b = <span class="hljs-built_in">find</span>(e[i].b), w = e[i].w;<br>    <span class="hljs-keyword">if</span> (a != b) &#123;<br>        res += w;<br>        p[a] = b;<br>    &#125;<br>&#125;<br><br>cout &lt;&lt; res &lt;&lt; endl;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="5-二维坐标映射为一维数组"><a href="#5-二维坐标映射为一维数组" class="headerlink" title="5. 二维坐标映射为一维数组"></a>5. <strong>二维坐标映射为一维数组</strong></h3><ul><li><p><strong>问题描述</strong>：在某些问题中，需要将二维坐标映射为一维数组的下标。</p></li><li><p><strong>解决方案</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> ids[K][K];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, t = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++, t++)<br>        ids[i][j] = t;<br></code></pre></td></tr></table></figure></li></ul><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. <strong>总结</strong></h3><ul><li><strong>最小生成树</strong>是图论中的一个重要概念，广泛应用于网络设计和资源优化。</li><li><strong>Prim算法</strong>和<strong>Kruskal算法</strong>是两种常用的最小生成树算法，各有优劣，适用于不同类型的图。</li><li><strong>并查集</strong>是处理最小生成树问题时常用的辅助数据结构，支持高效的合并和查找操作。</li><li><strong>变种问题</strong>（如最大边权最小化、必选边和可选边）可以通过对标准算法的扩展来解决。</li><li><strong>二维坐标映射</strong>是处理网格问题时的常用技巧，可以简化问题的复杂度。</li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="最短网络"><a href="#最短网络" class="headerlink" title="最短网络"></a>最短网络</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://www.luogu.com.cn/problem/P1546</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> w[N][N];<br><span class="hljs-type">int</span> dist[N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> t=<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(!st[j]&amp;&amp;(t==<span class="hljs-number">-1</span>||dist[t]&gt;dist[j])) t=j;<br>        &#125;<br><br>        res+=dist[t];<br>        st[t]=<span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++) dist[j]=<span class="hljs-built_in">min</span>(dist[j], w[t][j]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>            cin&gt;&gt;w[i][j];<br><br>    cout&lt;&lt;<span class="hljs-built_in">prim</span>()&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://www.luogu.com.cn/problem/P2820</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 注意这里不能保证所有计算机都连通，所以相当于在每个联通块内求最小生成树</span><br><span class="hljs-comment"> * 这里使用prim就比较麻烦，所以使用kruskal算法比较合适</span><br><span class="hljs-comment"> * 事实上，kruskal比prim更具有普适性</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">110</span>, M=<span class="hljs-number">210</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>    <span class="hljs-type">int</span> a, b, w;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Edge&amp;t)<span class="hljs-type">const</span>&#123;<br>        <span class="hljs-keyword">return</span> w&lt;t.w;<br>    &#125;<br>&#125;e[M];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> p[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x]!=x) p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) p[i]=i;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> a, b, w;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;<br>        e[i]=&#123;a, b, w&#125;;<br>    &#125;<br><br>    <span class="hljs-built_in">sort</span>(e, e+m);<br><br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> a=<span class="hljs-built_in">find</span>(e[i].a), b=<span class="hljs-built_in">find</span>(e[i].b), w=e[i].w;<br>        <span class="hljs-keyword">if</span>(a!=b) p[a]=b;<br>        <span class="hljs-keyword">else</span> res+=w;<span class="hljs-comment">// 这里记录的是要删除的边</span><br>    &#125;<br><br>    cout&lt;&lt;res&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="繁忙的都市"><a href="#繁忙的都市" class="headerlink" title="繁忙的都市"></a>繁忙的都市</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://www.luogu.com.cn/problem/P2330</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 朴素的最小生成树：求维持连通性的情况下，边权之和最小</span><br><span class="hljs-comment"> * 本题要求的是：维持连通性的情况下，最大边权最小</span><br><span class="hljs-comment"> * 事实上，用Kruskal算法一样能解决！</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">310</span>, M=<span class="hljs-number">8010</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>    <span class="hljs-type">int</span> a, b, w;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Edge&amp;t)<span class="hljs-type">const</span>&#123;<br>        <span class="hljs-keyword">return</span> w&lt;t.w;<br>    &#125;<br>&#125;e[M];<br><span class="hljs-type">int</span> p[N];<br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x]!=x) p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) p[i]=i;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> a, b, w;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;<br>        e[i]=&#123;a, b, w&#125;;<br>    &#125;<br><br>    <span class="hljs-built_in">sort</span>(e, e+m);<br><br>    <span class="hljs-type">int</span> max=<span class="hljs-number">-1</span>, s=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> a=<span class="hljs-built_in">find</span>(e[i].a), b=<span class="hljs-built_in">find</span>(e[i].b), w=e[i].w;<br>        <span class="hljs-keyword">if</span>(a!=b)&#123;<span class="hljs-comment">// 连上当前可选，连接这两点的最小的边，结果肯定是最优的</span><br>            p[a]=b;<br>            s++;<span class="hljs-comment">// 统计有几条边</span><br>            max=w;<span class="hljs-comment">// 最后一条肯定是最大的</span><br>        &#125;<br>    &#125;<br><br>    cout&lt;&lt;s&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;max&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="联络员"><a href="#联络员" class="headerlink" title="联络员"></a>联络员</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://blog.csdn.net/m0_62597063/article/details/125855338</span><br><span class="hljs-comment">// http://ybt.ssoier.cn:8088/problem_show.php?pid=1393</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2010</span>, M=<span class="hljs-number">10010</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>    <span class="hljs-type">int</span> a, b, w;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Edge&amp;t)<span class="hljs-type">const</span>&#123;<br>        <span class="hljs-keyword">return</span> w&lt;t.w;<br>    &#125;<br>&#125;e[M];<br><span class="hljs-type">int</span> p[N];<br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x]!=x) p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) p[i]=i;<br><br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>, cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> f, a, b, w;<br>        cin&gt;&gt;f&gt;&gt;a&gt;&gt;b&gt;&gt;w;<br>        <span class="hljs-keyword">if</span>(f==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-type">int</span> aa=<span class="hljs-built_in">find</span>(a), bb=<span class="hljs-built_in">find</span>(b);<br>            <span class="hljs-keyword">if</span>(aa!=bb) p[aa]=bb;<span class="hljs-comment">// 注意并查集的“并”操作，一定要先定位到根节点，再做并</span><br>            res+=w;<br>        &#125; <br>        <span class="hljs-keyword">else</span> e[cnt++]=&#123;a, b, w&#125;;<br>    &#125;<br><br>    <span class="hljs-built_in">sort</span>(e, e+cnt);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;cnt;i++)&#123;<br>        <span class="hljs-type">int</span> a=<span class="hljs-built_in">find</span>(e[i].a), b=<span class="hljs-built_in">find</span>(e[i].b), w=e[i].w;<br>        <span class="hljs-keyword">if</span>(a!=b)&#123;<br>            res+=w;<br>            p[a]=b;<br>        &#125;<br>    &#125;<br><br>    cout&lt;&lt;res&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="连接格点"><a href="#连接格点" class="headerlink" title="连接格点"></a>连接格点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// http://ybt.ssoier.cn:8088/problem_show.php?pid=1394</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span><span class="hljs-number">+10</span>, M=<span class="hljs-number">2e6</span><span class="hljs-number">+10</span>, K=<span class="hljs-number">1010</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>    <span class="hljs-type">int</span> a, b, w;<br>    <span class="hljs-comment">// bool operator&lt;(const Edge&amp;t)const&#123;</span><br>    <span class="hljs-comment">//     return w&lt;t.w;</span><br>    <span class="hljs-comment">// &#125;</span><br>&#125;e[M];<br><span class="hljs-type">int</span> ids[K][K];<br><span class="hljs-type">int</span> p[N];<br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x]!=x) p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br><br>    <span class="hljs-comment">//这一步是将二维坐标映射成一维数组的下标，值得学习</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>, t=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++, t++)<br>            ids[i][j]=t;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n*m;i++) p[i]=i;<br><br>    <span class="hljs-type">int</span> x1, y1, x2, y2;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2)&#123;<br>        <span class="hljs-type">int</span> a=ids[x1][y1], b=ids[x2][y2];<br>        p[<span class="hljs-built_in">find</span>(a)]=<span class="hljs-built_in">find</span>(b);<br>    &#125;<br><br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=m;k++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>, j=<span class="hljs-number">2</span>;j&lt;=n;i++, j++)&#123;<br>            e[cnt++]=&#123;ids[i][k], ids[j][k], <span class="hljs-number">1</span>&#125;;<br>        &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>, j=<span class="hljs-number">2</span>;j&lt;=m;i++, j++)&#123;<br>            e[cnt++]=&#123;ids[k][i], ids[k][j], <span class="hljs-number">2</span>&#125;;<br>        &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * &quot;还需要&quot;， 所以必选的边权不用加进去</span><br><span class="hljs-comment">     * 把所有边扫一遍也无伤大雅，因为必选边添加之后，两点处于联通状态，再次遇到时会自动跳过</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;cnt;i++)&#123;<br>        <span class="hljs-type">int</span> a=<span class="hljs-built_in">find</span>(e[i].a), b=<span class="hljs-built_in">find</span>(e[i].b), w=e[i].w;<br>        <span class="hljs-keyword">if</span>(a!=b)&#123;<br>            res+=w;<br>            p[a]=b;<br>        &#125;<br>    &#125;<br><br>    cout&lt;&lt;res&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>寒假练题计划</category>
      
      <category>提高算法</category>
      
      <category>图论</category>
      
      <category>最小生成树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>algorithm</tag>
      
      <tag>ACwing</tag>
      
      <tag>MST</tag>
      
      <tag>Kruskal</tag>
      
      <tag>Prim</tag>
      
      <tag>Disjoint-set</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025-02-01单源最短路径的综合应用</title>
    <link href="/2025/02/01/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%9A%84%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8/"/>
    <url>/2025/02/01/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%9A%84%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="单源最短路径的综合应用"><a href="#单源最短路径的综合应用" class="headerlink" title="单源最短路径的综合应用"></a>单源最短路径的综合应用</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><h3 id="1-单源最短路径问题概述"><a href="#1-单源最短路径问题概述" class="headerlink" title="1. 单源最短路径问题概述"></a>1. 单源最短路径问题概述</h3><p>单源最短路径问题是指在一个加权图中，找到从一个指定的源点到所有其他顶点的最短路径。常见的算法包括Dijkstra算法、Bellman-Ford算法和SPFA算法。选择合适的算法取决于图的特性和问题的具体需求。</p><h3 id="2-最短路径与其他知识点的结合应用"><a href="#2-最短路径与其他知识点的结合应用" class="headerlink" title="2. 最短路径与其他知识点的结合应用"></a>2. 最短路径与其他知识点的结合应用</h3><p>在实际问题中，单源最短路径问题常常与其他知识点结合，形成更复杂的场景。以下是一些常见的结合应用：</p><h4 id="2-1-最短路径与拓扑排序的结合"><a href="#2-1-最短路径与拓扑排序的结合" class="headerlink" title="2.1 最短路径与拓扑排序的结合"></a>2.1 最短路径与<strong>拓扑排序</strong>的结合</h4><p>在某些问题中，图中可能存在负权边，但这些负权边只出现在连通块之间，而不是连通块内部。此时，可以将连通块视为图中的节点，航线视为有向边，形成一个有向无环图（DAG）。通过拓扑排序处理这些连通块之间的关系，确保在更新最短路径时不会出现循环依赖。</p><p><strong>例题1：道路与航线</strong></p><ul><li><strong>问题描述</strong>：图中包含道路（双向、非负权）和航线（单向、可能有负权）。需要计算从起点到所有点的最短路径。</li><li><strong>解决方案</strong>：<ul><li>使用<strong>Dijkstra算法</strong>计算每个连通块内的最短路径，因为连通块内不存在负权边。</li><li>使用<strong>拓扑排序</strong>处理连通块之间的关系，因为负权边只出现在连通块之间，且不存在负权环。</li></ul></li></ul><h4 id="2-2-最短路径与二分法的结合"><a href="#2-2-最短路径与二分法的结合" class="headerlink" title="2.2 最短路径与二分法的结合"></a>2.2 最短路径与<strong>二分法</strong>的结合</h4><p>在某些问题中，路径的花费被定义为路径上第<em>k</em>+1大的边长。这种情况下，可以使用二分法结合最短路径算法来求解。</p><p><strong>例题2：通信线路</strong></p><ul><li><strong>问题描述</strong>：路径的花费定义为路径上第<em>k</em>+1大的边长。需要找到从起点到终点的最小花费。</li><li><strong>解决方案</strong>：<ul><li>使用<strong>二分法</strong>结合<strong>双端队列BFS</strong>（简化版Dijkstra）求解。将边权大于中值的边视为1，小于等于中值的边视为0，通过BFS计算从起点到终点的最短路径长度。</li></ul></li></ul><h4 id="2-3-最短路径与动态规划的结合"><a href="#2-3-最短路径与动态规划的结合" class="headerlink" title="2.3 最短路径与动态规划的结合"></a>2.3 最短路径与<strong>动态规划</strong>的结合</h4><p>在某些问题中，需要找到从起点到终点经过特定点的最短路径，或者路径上的最大利润最大化。这种情况下，可以结合动态规划和最短路径算法。</p><p><strong>例题3：新年好</strong></p><ul><li><strong>问题描述</strong>：需要找到从起点到终点经过6个特定点的最短路径。</li><li><strong>解决方案</strong>：<ul><li>使用<strong>堆优化版Dijkstra算法</strong>计算从每个特定点到所有点的最短路径。虽然不能处理负权边，但时间复杂度稳定。</li><li>使用<strong>DFS</strong>枚举6个点的排列，计算最短路径。</li></ul></li></ul><p><strong>例题4：最优贸易</strong></p><ul><li><strong>问题描述</strong>：在图中找到一条路径，使得路径上的最大利润最大化。</li><li><strong>解决方案</strong>：<ul><li>使用<strong>SPFA算法</strong>计算从起点到每个点的最小价格和最大利润。SPFA在处理负权边时效率较高。</li><li>动态规划结合最短路径算法，通过松弛操作更新路径上的最值。</li></ul></li></ul><h3 id="3-经验总结"><a href="#3-经验总结" class="headerlink" title="3. 经验总结"></a>3. 经验总结</h3><p>在解决单源最短路径问题时，以下经验可以帮助你更好地选择和应用算法：</p><h4 id="3-1-算法选择"><a href="#3-1-算法选择" class="headerlink" title="3.1 算法选择"></a>3.1 算法选择</h4><ul><li><strong>负权边</strong>：如果图中存在负权边，不能使用Dijkstra算法。可以选择Bellman-Ford算法或SPFA算法。</li><li><strong>负权环</strong>：如果图中可能存在负权环，需要使用Bellman-Ford算法检测负权环。</li><li><strong>稀疏图与稠密图</strong>：对于稀疏图，SPFA算法通常效率较高；对于稠密图，Dijkstra算法可能更合适。</li><li><strong>时间复杂度</strong>：在大规模数据下，需要考虑算法的时间复杂度和实际运行效率。</li></ul><h4 id="3-2-优化技巧"><a href="#3-2-优化技巧" class="headerlink" title="3.2 优化技巧"></a>3.2 优化技巧</h4><ul><li><strong>拓扑排序</strong>：在处理有向无环图（DAG）时，拓扑排序可以确保在更新最短路径时不会出现循环依赖。</li><li><strong>二分法</strong>：在某些问题中，二分法可以结合最短路径算法，通过减少问题规模来提高效率。</li><li><strong>动态规划</strong>：结合动态规划可以解决路径上的最值问题，如最大利润、最小花费等。</li></ul><h4 id="3-3-实际应用"><a href="#3-3-实际应用" class="headerlink" title="3.3 实际应用"></a>3.3 实际应用</h4><ul><li><strong>连通块处理</strong>：在图中存在多个连通块时，可以分别处理每个连通块内的最短路径问题，再通过拓扑排序处理连通块之间的关系。</li><li><strong>边权处理</strong>：在某些问题中，边权可能需要特殊处理，如将边权大于中值的边视为1，小于等于中值的边视为0。</li><li><strong>多源点问题</strong>：在需要计算多个源点到所有点的最短路径时，可以分别计算每个源点的最短路径，再通过动态规划或其他方法求解。</li></ul><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>单源最短路径问题在图论中具有广泛的应用。选择合适的算法需要根据图的特性和问题的具体需求。在实际问题中，单源最短路径问题常常与其他知识点结合，形成更复杂的场景。通过综合应用这些算法和知识点，可以解决各种复杂的最短路径问题。希望这些内容能帮助你更好地理解和应用这些算法。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="道路与航线"><a href="#道路与航线" class="headerlink" title="道路与航线"></a>道路与航线</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://blog.csdn.net/aochongbi5356/article/details/102286860</span><br><span class="hljs-comment">// https://www.luogu.com.cn/problem/P3008</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    在本题中，虽然图中存在负权边（航线），但仍然可以使用Dijkstra算法对每个连通块（由道路形成的强连通分量）进行最短路径计算，原因在于以下几个关键点：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    1. 连通块内部没有负权边</span><br><span class="hljs-comment">    道路的特性：题目中提到，道路是双向的，且权重非负（0 ≤ C_i ≤ 10,000）。这意味着在每个由道路形成的连通块内部，不存在负权边。</span><br><span class="hljs-comment">    Dijkstra算法的适用性：Dijkstra算法的核心是基于贪心策略，每次选择当前距离最短的节点进行扩展，并更新其邻接节点的距离。这种策略在图中所有边权非负的情况下是有效的。因此，在每个连通块内部，Dijkstra算法可以正确地计算出从起点到该连通块内所有节点的最短路径。</span><br><span class="hljs-comment">    2. 负权边只出现在连通块之间</span><br><span class="hljs-comment">    航线的特性：题目中提到，航线的权重可以是负数（−10,000 ≤ C_i ≤ 10,000），但航线是单向的，并且保证不存在负环。这意味着负权边只出现在连通块之间，而不是连通块内部。</span><br><span class="hljs-comment">    拓扑排序的作用：由于负权边只出现在连通块之间，且这些连通块之间形成了一个有向无环图（DAG），可以通过拓扑排序来处理这些连通块之间的关系。拓扑排序可以确保在更新最短路径时，按照正确的顺序处理每个连通块，从而避免负权边对最短路径计算的影响。</span><br><span class="hljs-comment">    3. 为什么Dijkstra算法不能直接处理负权边</span><br><span class="hljs-comment">    贪心策略失效：Dijkstra算法基于贪心策略，每次选择当前距离最短的节点进行扩展。如果图中存在负权边，已经确定为最短路径的节点可能会因为后续的负权边而变得不是最短的。例如，假设存在一条路径A→B→C，其中AB边的权重为1，BC边的权重为-2，那么从A到C的最短路径应该是A→B→C，总权重为-1。然而，Dijkstra算法可能会先选择A→B，然后遇到负权重边，导致无法找到正确的最短路径[^5^][^6^]。</span><br><span class="hljs-comment">    局部最优解问题：Dijkstra算法在每次迭代中选择当前距离最短的节点，这种贪心策略在存在负权边时可能导致陷入局部最优解，而无法找到全局最优解[^5^]。</span><br><span class="hljs-comment">    4. 如何在本题中正确处理负权边</span><br><span class="hljs-comment">    连通块内部：在每个连通块内，由于不存在负权边，可以安全地使用Dijkstra算法计算最短路径。</span><br><span class="hljs-comment">    连通块之间：将连通块看作图中的节点，航线看作有向边，形成一个DAG。通过拓扑排序处理这些连通块之间的关系，确保在更新最短路径时不会出现循环依赖[^1^][^9^]。</span><br><span class="hljs-comment">    拓扑排序的作用：拓扑排序可以确保在更新最短路径时，按照正确的顺序处理每个连通块，从而避免负权边对最短路径计算的影响[^1^][^9^]。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">25010</span>, M=<span class="hljs-number">150010</span>, INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> n, mr, mp, S;<br><span class="hljs-type">int</span> h[N], e[M], w[M], ne[M], idx;<br><span class="hljs-type">int</span> id[N];<br><span class="hljs-type">int</span> bcnt, bin[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; block[N];<br><span class="hljs-type">int</span> dist[N];<br><span class="hljs-type">bool</span> st[N]; <br>queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-comment">//全局队列用来存入度已经为0的团</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span>&#123;<br>    e[idx]=b, w[idx]=c, ne[idx]=h[a], h[a]=idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> bid)</span></span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * dfs构建团</span><br><span class="hljs-comment">    */</span><br>    id[u]=bid;<br>    block[bid].<span class="hljs-built_in">push_back</span>(u);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u];~i;i=ne[i])&#123;<br>        <span class="hljs-type">int</span> j=e[i];<br>        <span class="hljs-keyword">if</span>(!id[j]) <span class="hljs-built_in">dfs</span>(j, bid);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> bid)</span></span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 在团内部运行dijkstra</span><br><span class="hljs-comment">    */</span><br>    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ver:block[bid]) heap.<span class="hljs-built_in">push</span>(&#123;dist[ver], ver&#125;);<br><br>    <span class="hljs-keyword">while</span>(heap.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-keyword">auto</span> t=heap.<span class="hljs-built_in">top</span>();<br>        heap.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-type">int</span> ver=t.y, dis=t.x;<br>        <span class="hljs-keyword">if</span>(st[ver]) <span class="hljs-keyword">continue</span>;<br>        st[ver]=<span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[ver];~i;i=ne[i])&#123;<br>            <span class="hljs-type">int</span> j=e[i];<br><br>            <span class="hljs-keyword">if</span>(dist[j]&gt;dist[ver]+w[i])&#123;<br>                dist[j]=dist[ver]+w[i];<br>                <span class="hljs-keyword">if</span>(id[j]==id[ver]) heap.<span class="hljs-built_in">push</span>(&#123;dist[j], j&#125;);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(id[j]!=id[ver] &amp;&amp; --bin[id[j]] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(id[j]);<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">topsort</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 拓扑排序</span><br><span class="hljs-comment">     * 先将入度为0的团放入全局队列</span><br><span class="hljs-comment">     * 用团中的点做dijkstra去更新团内外的点的dist值，</span><br><span class="hljs-comment">     * 对于团外的点，每处理完一次，其所在的团入度就减1</span><br><span class="hljs-comment">     * 从而产生新的入度为0的团</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[S]=<span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=bcnt;i++)&#123;<br>        <span class="hljs-comment">//将所有入度为零的团入队</span><br>        <span class="hljs-keyword">if</span>(!bin[i]) q.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-type">int</span> t=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-built_in">dijkstra</span>(t);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;mr, &amp;mp, &amp;S);<br><br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-keyword">while</span>(mr--)&#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);<br>        <span class="hljs-built_in">add</span>(a, b, c), <span class="hljs-built_in">add</span>(b, a, c);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!id[i]) <span class="hljs-built_in">dfs</span>(i, ++bcnt);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(mp--)&#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);<br>        <span class="hljs-built_in">add</span>(a, b, c);<br>        bin[id[b]]++;<span class="hljs-comment">//记录入度</span><br>    &#125;<br><br>    <span class="hljs-built_in">topsort</span>();<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">if</span>(dist[i]&gt;INF/<span class="hljs-number">2</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO PATH&quot;</span>);<span class="hljs-comment">//针对带负权边的无穷边判断 </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dist[i]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="通信线路"><a href="#通信线路" class="headerlink" title="通信线路"></a>通信线路</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://blog.csdn.net/2301_76180325/article/details/133947071</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 此处路径的花费被定义为路径上第k+1大的边长</span><br><span class="hljs-comment"> * “最大值的最小值”，我们可以想到二分法</span><br><span class="hljs-comment"> * 边长范围&lt;=1e6</span><br><span class="hljs-comment"> * 二分区间定义为[0,1e6+1],原因如下：</span><br><span class="hljs-comment"> * 1. 最小花费可能为0，且最小为0</span><br><span class="hljs-comment"> * 2. 可能不存在连通路径，此时可视为花费无穷，在二分法中，结果为右边界，</span><br><span class="hljs-comment"> *    为了与边最大值1e6区分，右边界+1</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 关于check函数，使用以下方法：</span><br><span class="hljs-comment"> * 1. 对于一个判断的x，我们将每条大于x的边权视为1，小于等于x视为0</span><br><span class="hljs-comment"> * 2. 求一条从1到n最短路径，其长度res表示，路径上最少有res条边长度大于x</span><br><span class="hljs-comment"> * 3. 若res小于等于k，返回true，否则返回false</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 有关求最短路径采用的方法：</span><br><span class="hljs-comment"> * 考虑到边权只能是0或1，可以采用双端队列BFS(相当于简化版的dijkstra)求解，时间复杂度为线性</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1010</span>, M=<span class="hljs-number">20010</span>;<br><span class="hljs-type">int</span> n,m,k;<br><span class="hljs-type">int</span> e[M], w[M], ne[M], h[N], idx; <br>deque&lt;<span class="hljs-type">int</span>&gt; q;<br><span class="hljs-type">int</span> dist[N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span>&#123;<br>    e[idx]=b, w[idx]=c, ne[idx]=h[a], h[a]=idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> mid)</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    <span class="hljs-built_in">memset</span>(st, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> st);<br>    dist[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    q.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-type">int</span> t=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop_front</span>();<br><br>        <span class="hljs-keyword">if</span>(st[t]) <span class="hljs-keyword">continue</span>;<br>        st[t]=<span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[t];~i;i=ne[i])&#123;<br>            <span class="hljs-type">int</span> j=e[i], v=w[i]&gt;mid;<br>            <span class="hljs-keyword">if</span>(dist[j]&gt;dist[t]+v)&#123;<br>                dist[j]=dist[t]+v;<br>                <span class="hljs-keyword">if</span>(!v) q.<span class="hljs-built_in">push_front</span>(j);<br>                <span class="hljs-keyword">else</span> q.<span class="hljs-built_in">push_back</span>(j);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(dist[n]&lt;=k) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br><br>    <span class="hljs-built_in">memset</span>(h ,<span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        <span class="hljs-built_in">add</span>(a, b, c), <span class="hljs-built_in">add</span>(b, a ,c);<br>    &#125;<br><br>    <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>, r=<span class="hljs-number">1e6</span><span class="hljs-number">+1</span>;<br>    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>        <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) r=mid;<span class="hljs-comment">//[l,mid]</span><br>        <span class="hljs-keyword">else</span> l=mid<span class="hljs-number">+1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(l==<span class="hljs-number">1e6</span><span class="hljs-number">+1</span>) cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;l&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="新年好"><a href="#新年好" class="headerlink" title="新年好"></a>新年好</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://www.luogu.com.cn/problem/P5764</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 先求路线上六个点到其他所有点的最短路径长度，</span><br><span class="hljs-comment"> * 再dfs将六个点排列，求出最短路径，</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 这里spfa被卡，采用堆优化版的dijkstra可以AC，</span><br><span class="hljs-comment"> * 再次说明算法的取舍问题：</span><br><span class="hljs-comment"> * spfa：</span><br><span class="hljs-comment"> * 代码简单，</span><br><span class="hljs-comment"> * 而且可以处理负权边，</span><br><span class="hljs-comment"> * 但是在某些情况下时间复杂度不稳定，会导致TLE</span><br><span class="hljs-comment"> * 堆优化版Dijkstra：</span><br><span class="hljs-comment"> * 虽然不能处理负权边，</span><br><span class="hljs-comment"> * 同时时间复杂度在大多数情况下不如spfa，</span><br><span class="hljs-comment"> * 但是时间复杂度在任何时候都很稳定</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">//堆优化dijkstra</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">50010</span>, M = <span class="hljs-number">200010</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> h[N], e[M], ne[M], w[M], idx;<br><span class="hljs-type">int</span> source[<span class="hljs-number">6</span>];<br><span class="hljs-type">int</span> dist[<span class="hljs-number">6</span>][N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> dist[])</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-number">4</span>*N);<br>    dist[start] = <span class="hljs-number">0</span>;<br><br>    priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;&gt; heap;<span class="hljs-comment">//最小堆</span><br>    heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, start&#125;);<br><br>    <span class="hljs-keyword">while</span> (!heap.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> [d,u]=heap.<span class="hljs-built_in">top</span>();<br>        heap.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-keyword">if</span> (st[u]) <span class="hljs-keyword">continue</span>;<br>        st[u] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; dist[j] &gt; dist[u] + w[i]) &#123;<br>                dist[j] = dist[u] + w[i];<br>                heap.<span class="hljs-built_in">push</span>(&#123;dist[j], j&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">memset</span>(st, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(st)); <span class="hljs-comment">// 清空访问标记</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> dis)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == <span class="hljs-number">6</span>) <span class="hljs-keyword">return</span> dis;<br><br>    <span class="hljs-type">int</span> res = INF;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!st[i]) &#123;<br>            <span class="hljs-type">int</span> next = source[i];<br>            st[i] = <span class="hljs-literal">true</span>;<br>            res = <span class="hljs-built_in">min</span>(res, <span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>, i, dis + dist[start][next]));<br>            st[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><br>    source[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;source[i]);<br><br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> x, y, t;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;t);<br><br>        <span class="hljs-built_in">add</span>(x, y, t), <span class="hljs-built_in">add</span>(y, x, t);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) <span class="hljs-built_in">dijkstra</span>(source[i], dist[i]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">////spfa</span><br><span class="hljs-comment">// #include&lt;bits/stdc++.h&gt;</span><br><span class="hljs-comment">// using namespace std;</span><br><br><span class="hljs-comment">// const int N=50010, M=200010, INF=0x3f3f3f3f;</span><br><span class="hljs-comment">// int n,m;</span><br><span class="hljs-comment">// int h[N], e[M], ne[M], w[M], idx;</span><br><span class="hljs-comment">// int source[6];</span><br><span class="hljs-comment">// int q[N], dist[6][N];</span><br><span class="hljs-comment">// bool st[N];</span><br><br><span class="hljs-comment">// void add(int a, int b, int c)&#123;</span><br><span class="hljs-comment">//     e[idx]=b, ne[idx]=h[a], w[idx]=c, h[a]=idx++;</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">// void spfa(int start, int dist[])&#123;</span><br><span class="hljs-comment">//     memset(dist, 0x3f, 4*N);//每个int， 4个字节</span><br><span class="hljs-comment">//     dist[start]=0;</span><br><br><span class="hljs-comment">//     int hh=0, tt=1;</span><br><span class="hljs-comment">//     q[0]=start;</span><br><br><span class="hljs-comment">//     while(hh!=tt)&#123;</span><br><span class="hljs-comment">//         int t=q[hh++];</span><br><span class="hljs-comment">//         if(hh==N) hh=0;</span><br><span class="hljs-comment">//         st[t]=false;</span><br><br><span class="hljs-comment">//         for(int i=h[t];~i;i=ne[i])&#123;</span><br><span class="hljs-comment">//             int j=e[i];</span><br><span class="hljs-comment">//             if(dist[j]&gt;dist[t]+w[i])&#123;</span><br><span class="hljs-comment">//                 dist[j]=dist[t]+w[i];</span><br><span class="hljs-comment">//                 if(!st[j])&#123;</span><br><span class="hljs-comment">//                     q[tt++]=j;</span><br><span class="hljs-comment">//                     if(tt==N) tt=0;</span><br><span class="hljs-comment">//                     st[j]=true;</span><br><span class="hljs-comment">//                 &#125;</span><br><span class="hljs-comment">//             &#125;</span><br><span class="hljs-comment">//         &#125;</span><br><span class="hljs-comment">//     &#125;</span><br><br><span class="hljs-comment">// &#125; </span><br><br><span class="hljs-comment">// int dfs(int u, int start, int dis)&#123;</span><br><span class="hljs-comment">//     if(u==6) return dis;</span><br><br><span class="hljs-comment">//     int res=INF;</span><br><span class="hljs-comment">//     for(int i=1;i&lt;=5;i++)</span><br><span class="hljs-comment">//         if(!st[i])&#123;</span><br><span class="hljs-comment">//             int next=source[i];</span><br><span class="hljs-comment">//             st[i]=true;</span><br><span class="hljs-comment">//             res=min(res, dfs(u+1, i, dis+dist[start][next]));</span><br><span class="hljs-comment">//             st[i]=false;</span><br><span class="hljs-comment">//         &#125;</span><br><br><span class="hljs-comment">//     return res;</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">// void work()&#123;</span><br><span class="hljs-comment">//     scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><br><span class="hljs-comment">//     source[0]=1;</span><br><span class="hljs-comment">//     for(int i=1;i&lt;=5;i++) scanf(&quot;%d&quot;, &amp;source[i]);</span><br><br><span class="hljs-comment">//     memset(h, -1, sizeof h);</span><br><span class="hljs-comment">//     while(m--)&#123;</span><br><span class="hljs-comment">//         int x,y,t;</span><br><span class="hljs-comment">//         scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;t);</span><br><br><span class="hljs-comment">//         add(x, y, t), add(y, x, t);</span><br><span class="hljs-comment">//     &#125;</span><br><br><span class="hljs-comment">//     for(int i=0;i&lt;6;i++) spfa(source[i], dist[i]);</span><br><br><span class="hljs-comment">//     printf(&quot;%d\n&quot;, dfs(1,0,0));</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">// int main()&#123;</span><br><span class="hljs-comment">//     work();</span><br><span class="hljs-comment">//     return 0;</span><br><span class="hljs-comment">// &#125;</span><br><br><br></code></pre></td></tr></table></figure><h3 id="最优贸易"><a href="#最优贸易" class="headerlink" title="最优贸易"></a>最优贸易</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://www.luogu.com.cn/problem/P1073</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 动态规划+最短路径</span><br><span class="hljs-comment"> * 对于每一个以1为起点的路径：</span><br><span class="hljs-comment"> * 1. 可以预先求出1到某一结点i路径上水晶球最便宜的价格mn[i]</span><br><span class="hljs-comment"> * 2. 求1到某一结点i路径上最大利润val[i]时，相对于1到该结点前一个结点i的路径上的最大利润v来说：</span><br><span class="hljs-comment"> * 更新的可能值只可能是p[i]-mn[i]</span><br><span class="hljs-comment"> * 所以更新val[i]=max(p[i]-mn[i], max&#123;v&#125;)</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 值得注意的是，当用求最短路径的方法去求路径上最值的时候，</span><br><span class="hljs-comment"> * dijkstra不能用判重标记</span><br><span class="hljs-comment"> * 或者说这里根本就不适合使用dijkstra</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 使用bellman-ford算法，可以处理负边也可以处理负权环</span><br><span class="hljs-comment"> * spfa是bellman-ford的优化版，平均效率更高，但是处理负权环能力较差，还有就是当m*n比较大时不可用</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 用spfa算法去做最值,完全能过</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ft first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+10</span>, M=<span class="hljs-number">1e6</span><span class="hljs-number">+10</span>, INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;<br><span class="hljs-type">int</span> mn[N], val[N];<br><span class="hljs-type">int</span> p[N];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> q[N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br>    e[idx]=b, ne[idx]=h[a], h[a]=idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spfa_mn</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(mn, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> mn);<br>    <span class="hljs-built_in">memset</span>(st, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> st);<br>    mn[<span class="hljs-number">1</span>]=p[<span class="hljs-number">1</span>];<br><br>    <span class="hljs-type">int</span> hh=<span class="hljs-number">0</span>, tt=<span class="hljs-number">1</span>;<br>    q[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>, st[<span class="hljs-number">1</span>]=<span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">while</span>(hh!=tt)&#123;<br>        <span class="hljs-type">int</span> t=q[hh++];<br>        <span class="hljs-keyword">if</span>(hh==N) hh=<span class="hljs-number">0</span>;<br>        st[t]=<span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[t];~i;i=ne[i])&#123;<br>            <span class="hljs-type">int</span> j=e[i];<br>            <span class="hljs-keyword">if</span>(mn[j]&gt;<span class="hljs-built_in">min</span>(p[j], mn[t]))&#123;<br>                mn[j]=<span class="hljs-built_in">min</span>(p[j], mn[t]);<br>                <span class="hljs-keyword">if</span>(!st[j])&#123;<br>                    q[tt++]=j;<br>                    <span class="hljs-keyword">if</span>(tt==N) tt=<span class="hljs-number">0</span>;<br>                    st[j]=<span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spfa_val</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(val, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> val);<br>    <span class="hljs-built_in">memset</span>(st, <span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> st);<br>    val[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> hh=<span class="hljs-number">0</span>, tt=<span class="hljs-number">1</span>;<br>    q[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    st[<span class="hljs-number">1</span>]=<span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">while</span>(hh!=tt)&#123;<br>        <span class="hljs-type">int</span> t=q[hh++];<br>        <span class="hljs-keyword">if</span>(hh==N) hh=<span class="hljs-number">0</span>;<br>        st[t]=<span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[t];~i;i=ne[i])&#123;<br>            <span class="hljs-type">int</span> j=e[i];<br>            <span class="hljs-keyword">if</span>(val[j]&lt;<span class="hljs-built_in">max</span>(val[t], p[j]-mn[j]))&#123;<br>                val[j]=<span class="hljs-built_in">max</span>(val[t], p[j]-mn[j]);<br>                <span class="hljs-keyword">if</span>(!st[j])&#123;<br>                    q[tt++]=j;<br>                    <span class="hljs-keyword">if</span>(tt==N) tt=<span class="hljs-number">0</span>;<br>                    st[j]=<span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;p[i]);<br><br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> x, y, z;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);<br><br>        <span class="hljs-keyword">if</span>(z==<span class="hljs-number">1</span>) <span class="hljs-built_in">add</span>(x,y);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(z==<span class="hljs-number">2</span>) <span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);<br>    &#125;<br><br>    <span class="hljs-built_in">spfa_mn</span>();<br>    <span class="hljs-built_in">spfa_val</span>();<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, val[n]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-comment">//// 不判重的dijkstra, 勉强AC</span><br><span class="hljs-comment">// #include&lt;bits/stdc++.h&gt;</span><br><span class="hljs-comment">// using namespace std;</span><br><br><span class="hljs-comment">// #define ft first</span><br><span class="hljs-comment">// #define se second</span><br><br><span class="hljs-comment">// typedef pair&lt;int, int&gt; PII;</span><br><br><span class="hljs-comment">// const int N=1e5+10, M=1e6+10, INF=0x3f3f3f3f;</span><br><span class="hljs-comment">// int h[N], e[M], ne[M], idx;</span><br><span class="hljs-comment">// int mn[N], val[N];</span><br><span class="hljs-comment">// int p[N];</span><br><span class="hljs-comment">// int n, m;</span><br><span class="hljs-comment">// bool st[N];</span><br><br><span class="hljs-comment">// void add(int a, int b)&#123;</span><br><span class="hljs-comment">//     e[idx]=b, ne[idx]=h[a], h[a]=idx++;</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">// void dijkstra_mn()&#123;</span><br><span class="hljs-comment">//     memset(mn, 0x3f, sizeof mn);</span><br><span class="hljs-comment">//     memset(st, 0, sizeof st);</span><br><span class="hljs-comment">//     mn[1]=p[1];</span><br><br><span class="hljs-comment">//     priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><br><span class="hljs-comment">//     heap.push(&#123;mn[1], 1&#125;);</span><br><br><span class="hljs-comment">//     while(heap.size())&#123;</span><br><span class="hljs-comment">//         auto [price, t]=heap.top();</span><br><span class="hljs-comment">//         heap.pop();</span><br><br><span class="hljs-comment">//         // if(st[t]) continue;</span><br><span class="hljs-comment">//         // st[t]=true;</span><br><br><span class="hljs-comment">//         for(int i=h[t];~i;i=ne[i])&#123;</span><br><span class="hljs-comment">//             int j=e[i];</span><br><span class="hljs-comment">//             if(mn[j]&gt;min(price, p[j]))&#123;</span><br><span class="hljs-comment">//                 mn[j]=min(price, p[j]);</span><br><span class="hljs-comment">//                 heap.push(&#123;mn[j], j&#125;);</span><br><span class="hljs-comment">//             &#125;</span><br><span class="hljs-comment">//         &#125;</span><br><span class="hljs-comment">//     &#125; </span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">// void dijkstra_val()&#123;</span><br><span class="hljs-comment">//     memset(val, 0, sizeof val);</span><br><span class="hljs-comment">//     memset(st, 0,sizeof st);</span><br><span class="hljs-comment">//     val[1]=0;</span><br><br><span class="hljs-comment">//     priority_queue&lt;PII, vector&lt;PII&gt;&gt; heap;</span><br><span class="hljs-comment">//     heap.push(&#123;val[1], 1&#125;);</span><br><br><span class="hljs-comment">//     while(heap.size())&#123;</span><br><span class="hljs-comment">//         auto [v, t] = heap.top();</span><br><span class="hljs-comment">//         heap.pop();</span><br><br><span class="hljs-comment">//         // if(st[t]) continue;</span><br><span class="hljs-comment">//         // st[t]=true;</span><br><br><span class="hljs-comment">//         for(int i=h[t];~i;i=ne[i])&#123;</span><br><span class="hljs-comment">//             int j=e[i];</span><br><br><span class="hljs-comment">//             if(val[j]&lt;max(val[t], p[j]-mn[j]))&#123;</span><br><span class="hljs-comment">//                 val[j]=max(val[t], p[j]-mn[j]);</span><br><span class="hljs-comment">//                 heap.push(&#123;val[j], j&#125;);</span><br><span class="hljs-comment">//             &#125;</span><br><span class="hljs-comment">//         &#125;</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">// void work()&#123;</span><br><span class="hljs-comment">//     scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><br><span class="hljs-comment">//     for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;, &amp;p[i]);</span><br><br><span class="hljs-comment">//     memset(h, -1, sizeof h);</span><br><span class="hljs-comment">//     while(m--)&#123;</span><br><span class="hljs-comment">//         int x, y, z;</span><br><span class="hljs-comment">//         scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z);</span><br><br><span class="hljs-comment">//         if(z==1) add(x,y);</span><br><span class="hljs-comment">//         else if(z==2) add(x,y), add(y,x);</span><br><span class="hljs-comment">//     &#125;</span><br><br><span class="hljs-comment">//     dijkstra_mn();</span><br><span class="hljs-comment">//     dijkstra_val();</span><br><br><span class="hljs-comment">//     printf(&quot;%d\n&quot;, val[n]);</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">// int main()&#123;</span><br><span class="hljs-comment">//     work();</span><br><span class="hljs-comment">//     return 0;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>寒假练题计划</category>
      
      <category>提高算法</category>
      
      <category>图论</category>
      
      <category>单源最短路径</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>algorithm</tag>
      
      <tag>ACwing</tag>
      
      <tag>BFS</tag>
      
      <tag>Dijsktra</tag>
      
      <tag>SPFA</tag>
      
      <tag>Floyd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025-01-30单源最短路径建图方式</title>
    <link href="/2025/01/30/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%BB%BA%E5%9B%BE%E6%96%B9%E5%BC%8F/"/>
    <url>/2025/01/30/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%BB%BA%E5%9B%BE%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="单源最短路径建图方式"><a href="#单源最短路径建图方式" class="headerlink" title="单源最短路径建图方式"></a>单源最短路径建图方式</h1><h2 id="1-主要内容"><a href="#1-主要内容" class="headerlink" title="1. 主要内容"></a>1. 主要内容</h2><h3 id="1-SPFA算法模板"><a href="#1-SPFA算法模板" class="headerlink" title="1. SPFA算法模板"></a><strong>1. SPFA算法模板</strong></h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = ..., M = ...; <span class="hljs-comment">// 根据题目调整节点和边的数量</span><br><span class="hljs-type">int</span> h[N], e[M], w[M], ne[M], idx; <span class="hljs-comment">// 链式前向星存储图</span><br><span class="hljs-type">int</span> dist[N], q[N]; <span class="hljs-comment">// dist存储最短距离，q为循环队列</span><br><span class="hljs-type">bool</span> st[N]; <span class="hljs-comment">// 标记数组，用于队列去重</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123; <span class="hljs-comment">// 添加边</span><br>    e[idx] = b;<br>    w[idx] = c;<br>    ne[idx] = h[a];<br>    h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> start)</span> </span>&#123; <span class="hljs-comment">// SPFA算法</span><br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist); <span class="hljs-comment">// 初始化距离为正无穷</span><br>    dist[start] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 起点距离为0</span><br>    <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">1</span>;<br>    q[<span class="hljs-number">0</span>] = start, st[start] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 起点入队</span><br><br>    <span class="hljs-keyword">while</span> (hh != tt) &#123;<br>        <span class="hljs-type">int</span> t = q[hh++];<br>        <span class="hljs-keyword">if</span> (hh == N) hh = <span class="hljs-number">0</span>; <span class="hljs-comment">// 队列循环操作</span><br>        st[t] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 当前节点出队</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i]) &#123; <span class="hljs-comment">// 遍历邻接表</span><br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i]) &#123; <span class="hljs-comment">// 更新距离</span><br>                dist[j] = dist[t] + w[i];<br>                <span class="hljs-keyword">if</span> (!st[j]) &#123; <span class="hljs-comment">// 如果未入队，则入队</span><br>                    q[tt++] = j;<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">if</span> (tt == N) tt = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><ul><li><strong>无负权环的加权图</strong>：适用于边权可以为正或零的图，但不能有负权环。</li><li><strong>稀疏图</strong>：当图的边数较少时（即边数 m 远小于 n2），SPFA 的效率较高。</li><li><strong>需要频繁更新最短路径</strong>：例如在动态图中，边的权重可能会变化，SPFA 可以较快地重新计算最短路径。</li></ul><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a><strong>时间复杂度</strong></h4><ul><li><strong>平均情况</strong>：O(m)，其中 m 是边的数量。</li><li><strong>最坏情况</strong>：O(n⋅m)，其中 n 是节点数量。在某些特殊构造的图中（如所有节点都连成一条链），SPFA 的性能会退化到接近 O(n⋅m)。</li></ul><h4 id="数据规模"><a href="#数据规模" class="headerlink" title="数据规模"></a><strong>数据规模</strong></h4><ul><li><strong>节点数 n</strong>：通常适用于 n≤10^5 的情况。</li><li><strong>边数 m</strong>：通常适用于 m≤10^6 的情况。</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h4><ul><li><strong>代码简单</strong>：实现起来相对容易，适合快速开发。</li><li><strong>效率较高</strong>：在稀疏图中表现良好，尤其是在实际应用中，平均情况下效率较高。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ul><li><strong>容易被卡</strong>：在某些特殊构造的图中（如所有节点都连成一条链），SPFA 的性能会退化到接近 O(n⋅m)，可能会被卡成 O(n2) 的复杂度。</li></ul><h3 id="2-Dijkstra算法模板"><a href="#2-Dijkstra算法模板" class="headerlink" title="2. Dijkstra算法模板"></a><strong>2. Dijkstra算法模板</strong></h3><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = ...; <span class="hljs-comment">// 根据题目调整节点数量</span><br><span class="hljs-type">int</span> g[N][N]; <span class="hljs-comment">// 邻接矩阵存储图</span><br><span class="hljs-type">int</span> dist[N]; <span class="hljs-comment">// 存储最短距离</span><br><span class="hljs-type">bool</span> st[N]; <span class="hljs-comment">// 标记数组</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> start)</span> </span>&#123; <span class="hljs-comment">// Dijkstra算法</span><br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist); <span class="hljs-comment">// 初始化距离为正无穷</span><br>    dist[start] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 起点距离为0</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123; <span class="hljs-comment">// 遍历所有节点</span><br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123; <span class="hljs-comment">// 找到未访问的最短距离节点</span><br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t])) &#123;<br>                t = j;<br>            &#125;<br>        &#125;<br>        st[t] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记为已访问</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123; <span class="hljs-comment">// 更新邻接节点的距离</span><br>            dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[t] + g[t][j]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><ul><li><strong>非负权图</strong>：适用于所有边权非负的图。</li><li><strong>稠密图</strong>：当图的边数较多时（接近 n2），Dijkstra 算法表现良好。</li><li><strong>需要精确计算最短路径</strong>：适用于对最短路径精度要求较高的场景。</li></ul><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a><strong>时间复杂度</strong></h4><ul><li><strong>朴素版本</strong>：O(n2)，其中 n 是节点数量。</li><li><strong>堆优化版本</strong>：O(mlogn)，其中 m 是边的数量。</li></ul><h4 id="数据规模-1"><a href="#数据规模-1" class="headerlink" title="数据规模"></a><strong>数据规模</strong></h4><ul><li><strong>节点数 n</strong>：朴素版本适用于 n≤10^3，堆优化版本适用于 n≤10^5。</li><li><strong>边数 m</strong>：堆优化版本适用于 m≤10^6。</li></ul><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a><strong>优点</strong></h4><ul><li><strong>稳定</strong>：时间复杂度稳定，不会像 SPFA 那样容易被卡。</li><li><strong>适用范围广</strong>：适用于所有非负权图。</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ul><li><strong>代码复杂度</strong>：堆优化版本的代码相对复杂，需要使用优先队列。</li><li><strong>效率在稀疏图中不如 SPFA</strong>：在稀疏图中，SPFA 的平均性能通常优于 Dijkstra。</li></ul><h3 id="3-Floyd算法模板"><a href="#3-Floyd算法模板" class="headerlink" title="3. Floyd算法模板"></a><strong>3. Floyd算法模板</strong></h3><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = ...; <span class="hljs-comment">// 根据题目调整节点数量</span><br><span class="hljs-type">int</span> d[N][N]; <span class="hljs-comment">// 邻接矩阵存储图</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// Floyd算法</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; n; k++) &#123; <span class="hljs-comment">// 中间节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123; <span class="hljs-comment">// 起点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123; <span class="hljs-comment">// 终点</span><br>                d[i][j] = <span class="hljs-built_in">min</span>(d[i][j], d[i][k] + d[k][j]); <span class="hljs-comment">// 更新最短距离</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><ul><li><strong>多源最短路径问题</strong>：适用于需要计算所有节点对之间的最短路径的情况。</li><li><strong>小规模图</strong>：由于时间复杂度较高，适用于节点数量较小的图。</li></ul><h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a><strong>时间复杂度</strong></h4><ul><li><strong>固定复杂度</strong>：O(n3)，其中 n 是节点数量。</li></ul><h4 id="数据规模-2"><a href="#数据规模-2" class="headerlink" title="数据规模"></a><strong>数据规模</strong></h4><ul><li><strong>节点数 n</strong>：通常适用于 n≤500 的情况。</li><li><strong>边数 m</strong>：由于是多源最短路径问题，边数通常不是主要限制。</li></ul><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a><strong>优点</strong></h4><ul><li><strong>代码简单</strong>：实现起来非常简单，适合快速开发。</li><li><strong>功能强大</strong>：可以一次性计算所有节点对的最短路径。</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ul><li><strong>时间复杂度高</strong>：不适用于大规模图。</li><li><strong>空间复杂度高</strong>：需要 O(n2) 的空间来存储邻接矩阵。</li></ul><h3 id="4-BFS算法模板（适用于无权图）"><a href="#4-BFS算法模板（适用于无权图）" class="headerlink" title="4. BFS算法模板（适用于无权图）"></a><strong>4. BFS算法模板（适用于无权图）</strong></h3><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = ...; <span class="hljs-comment">// 根据题目调整节点数量</span><br><span class="hljs-type">bool</span> g[N][N]; <span class="hljs-comment">// 邻接矩阵存储图</span><br><span class="hljs-type">int</span> dist[N]; <span class="hljs-comment">// 存储最短距离</span><br><span class="hljs-type">int</span> q[N]; <span class="hljs-comment">// 循环队列</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start)</span> </span>&#123; <span class="hljs-comment">// BFS算法</span><br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist); <span class="hljs-comment">// 初始化距离为正无穷</span><br>    dist[start] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 起点距离为0</span><br>    <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">1</span>;<br>    q[<span class="hljs-number">0</span>] = start; <span class="hljs-comment">// 起点入队</span><br><br>    <span class="hljs-keyword">while</span> (hh != tt) &#123;<br>        <span class="hljs-type">int</span> t = q[hh++];<br>        <span class="hljs-keyword">if</span> (hh == N) hh = <span class="hljs-number">0</span>; <span class="hljs-comment">// 队列循环操作</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123; <span class="hljs-comment">// 遍历所有节点</span><br>            <span class="hljs-keyword">if</span> (g[t][i] &amp;&amp; dist[i] &gt; dist[t] + <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 如果有边且距离更短</span><br>                dist[i] = dist[t] + <span class="hljs-number">1</span>; <span class="hljs-comment">// 更新距离</span><br>                q[tt++] = i; <span class="hljs-comment">// 入队</span><br>                <span class="hljs-keyword">if</span> (tt == N) tt = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="适用场景-3"><a href="#适用场景-3" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><ul><li><strong>无权图</strong>：适用于所有边权为 1 的无权图。</li><li><strong>稀疏图</strong>：在稀疏图中表现良好，尤其是当图的边数较少时。</li></ul><h4 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a><strong>时间复杂度</strong></h4><ul><li><strong>固定复杂度</strong>：O(n+m)，其中 n 是节点数量，m 是边的数量。</li></ul><h4 id="数据规模-3"><a href="#数据规模-3" class="headerlink" title="数据规模"></a><strong>数据规模</strong></h4><ul><li><strong>节点数 n</strong>：通常适用于 n≤10^5 的情况。</li><li><strong>边数 m</strong>：通常适用于 m≤10^6 的情况。</li></ul><h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a><strong>优点</strong></h4><ul><li><strong>代码简单</strong>：实现起来非常简单。</li><li><strong>效率高</strong>：在无权图中，时间复杂度为 O(n+m)，非常高效。</li></ul><h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ul><li><strong>仅适用于无权图</strong>：不能处理有权图。</li></ul><h3 id="5-Dijkstra算法（堆优化版）模板"><a href="#5-Dijkstra算法（堆优化版）模板" class="headerlink" title="5. Dijkstra算法（堆优化版）模板"></a><strong>5. Dijkstra算法（堆优化版）模板</strong></h3><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = ..., M = ...; <span class="hljs-comment">// 根据题目调整节点和边的数量</span><br><span class="hljs-type">int</span> h[N], e[M], w[M], ne[M], idx; <span class="hljs-comment">// 链式前向星存储图</span><br><span class="hljs-type">int</span> dist[N]; <span class="hljs-comment">// 存储最短距离</span><br><span class="hljs-type">bool</span> st[N]; <span class="hljs-comment">// 标记数组</span><br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, greater&lt;&gt;&gt; pq; <span class="hljs-comment">// 小根堆</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123; <span class="hljs-comment">// 添加边</span><br>    e[idx] = b;<br>    w[idx] = c;<br>    ne[idx] = h[a];<br>    h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> start)</span> </span>&#123; <span class="hljs-comment">// Dijkstra算法（堆优化版）</span><br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist); <span class="hljs-comment">// 初始化距离为正无穷</span><br>    dist[start] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 起点距离为0</span><br>    pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, start&#125;); <span class="hljs-comment">// 起点入堆</span><br><br>    <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> [d, t] = pq.<span class="hljs-built_in">top</span>();<br>        pq.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-keyword">if</span> (st[t]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 如果已经访问过，则跳过</span><br>        st[t] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i]) &#123; <span class="hljs-comment">// 遍历邻接表</span><br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i]) &#123; <span class="hljs-comment">// 更新距离</span><br>                dist[j] = dist[t] + w[i];<br>                pq.<span class="hljs-built_in">push</span>(&#123;dist[j], j&#125;); <span class="hljs-comment">// 入堆</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="适用场景-4"><a href="#适用场景-4" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><ul><li><strong>非负权图</strong>：适用于所有边权非负的图。</li><li><strong>大规模图</strong>：由于使用了优先队列优化，适用于大规模图。</li></ul><h4 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a><strong>时间复杂度</strong></h4><ul><li><strong>固定复杂度</strong>：O(mlogn)，其中 m 是边的数量，n 是节点数量。</li></ul><h4 id="数据规模-4"><a href="#数据规模-4" class="headerlink" title="数据规模"></a><strong>数据规模</strong></h4><ul><li><strong>节点数 n</strong>：通常适用于 n≤10^5 的情况。</li><li><strong>边数 m</strong>：通常适用于 m≤10^6 的情况。</li></ul><h4 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a><strong>优点</strong></h4><ul><li><strong>稳定</strong>：时间复杂度稳定，不会像 SPFA 那样容易被卡。</li><li><strong>效率高</strong>：在大规模图中表现良好。</li></ul><h4 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ul><li><strong>代码复杂度</strong>：需要使用优先队列，代码相对复杂。</li><li><strong>空间复杂度</strong>：需要额外的空间来存储优先队列。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul><li><strong>SPFA</strong>：适合稀疏图和需要频繁更新的场景，但容易被卡。</li><li><strong>Dijkstra（朴素）</strong>：适合小规模稠密图，代码简单但效率较低。</li><li><strong>Dijkstra（堆优化）</strong>：适合大规模图，效率高但代码复杂。</li><li><strong>Floyd</strong>：适合多源最短路径问题，适合小规模图。</li><li><strong>BFS</strong>：适合无权图，效率高且代码简单。</li></ul><p>在实际应用中，选择哪种算法需要根据具体问题的规模和特性来决定。</p><h2 id="2-例题"><a href="#2-例题" class="headerlink" title="2. 例题"></a>2. 例题</h2><h3 id="热浪"><a href="#热浪" class="headerlink" title="热浪"></a>热浪</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://blog.csdn.net/qq_30277239/article/details/106104598</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2510</span>, M=<span class="hljs-number">6200</span>*<span class="hljs-number">2</span><span class="hljs-number">+10</span>;<span class="hljs-comment">//</span><br><span class="hljs-type">int</span> h[N], <span class="hljs-comment">// 结点对应链表表头</span><br>    e[M], <span class="hljs-comment">// 链表结点值</span><br>    w[M], <span class="hljs-comment">// 权重</span><br>    ne[M],<span class="hljs-comment">// next指针</span><br>    idx;  <span class="hljs-comment">// 下标</span><br><span class="hljs-type">int</span> n,m,S,T;<br><span class="hljs-type">int</span> dist[N], <br>    q[N];     <span class="hljs-comment">// 循环队列</span><br><span class="hljs-type">bool</span> st[N]; <span class="hljs-comment">// 队列去重标记，true表示已经入队， false表示尚未入队</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">spfa算法，时间复杂度比dijstra更低，但是容易被卡</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<span class="hljs-comment">//设为正无穷</span><br>    dist[S]=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> hh=<span class="hljs-number">0</span>, tt=<span class="hljs-number">1</span>;<br>    q[<span class="hljs-number">0</span>]=S, st[S]=<span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">while</span>(hh!=tt)&#123;<br>        <span class="hljs-type">int</span> t=q[hh++];<br>        <span class="hljs-keyword">if</span>(hh==N) hh=<span class="hljs-number">0</span>;<br>        st[t]=<span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[t]; ~i; i=ne[i])&#123;<br>            <span class="hljs-type">int</span> j=e[i];<br>            <span class="hljs-keyword">if</span>(dist[j]&gt;dist[t]+w[i])&#123;<br>                dist[j]=dist[t]+w[i];<br>                <span class="hljs-keyword">if</span>(!st[j])&#123;<br>                    q[tt++]=j;<br>                    st[j]=<span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">if</span>(tt==N) tt=<span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span>&#123;<br>    <span class="hljs-comment">//头插法</span><br>    e[idx]=b;<br>    w[idx]=c;<br>    ne[idx]=h[a];<br>    h[a]=idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;S&gt;&gt;T;<br><br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> a,b,c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        <span class="hljs-built_in">add</span>(a,b,c), <span class="hljs-built_in">add</span>(b,a,c);<br>    &#125;<br><br>    <span class="hljs-built_in">spfa</span>();<br><br>    cout&lt;&lt;dist[T]&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="香甜的黄油"><a href="#香甜的黄油" class="headerlink" title="香甜的黄油"></a>香甜的黄油</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://blog.csdn.net/2301_76180325/article/details/133858261</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 题目本身是一个多源最短路径问题，一般想到Floyd（n^3复杂度）， 但是观察问题规模n~800，所以要考虑优化</span><br><span class="hljs-comment"> * n次Dij：没区别，复杂度还是n^3</span><br><span class="hljs-comment"> * n次堆优化版Dij：复杂度是n*m*log(n)，可行</span><br><span class="hljs-comment"> * n次spfa：复杂度是n*m，可行，且代码相对简单，但是有概率会被卡</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">810</span>, M=<span class="hljs-number">3000</span>, INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-type">int</span> n, p, m;<br><span class="hljs-type">int</span> h[N], e[M], w[M], ne[M], idx;<br><span class="hljs-type">int</span> id[N];<br><span class="hljs-type">int</span> dist[N], q[M];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span>&#123;<br>    e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> start)</span></span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 返回以start为起点到所有奶牛的单源最短路径之和</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dist);<br>    dist[start]=<span class="hljs-number">0</span>;<span class="hljs-comment">//起始结点初始化</span><br><br>    <span class="hljs-type">int</span> hh=<span class="hljs-number">0</span>,tt=<span class="hljs-number">1</span>;<br>    q[<span class="hljs-number">0</span>]=start,st[start]=<span class="hljs-literal">true</span>;<span class="hljs-comment">//起始节点入队</span><br><br>    <span class="hljs-keyword">while</span>(hh!=tt)&#123;<br>        <span class="hljs-type">int</span> t=q[hh++];<br>        <span class="hljs-keyword">if</span>(hh==N) hh=<span class="hljs-number">0</span>;<br>        st[t]=<span class="hljs-literal">false</span>;<span class="hljs-comment">//队头结点出队操作</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[t];~i;i=ne[i])&#123;<br>            <span class="hljs-comment">//遍历队头结点邻接表，更新距离</span><br>            <span class="hljs-type">int</span> j=e[i];<br>            <span class="hljs-keyword">if</span>(dist[j]&gt;dist[t]+w[i])&#123;<br>                dist[j]=dist[t]+w[i];<br>                <span class="hljs-keyword">if</span>(!st[j])&#123;<br>                    <span class="hljs-comment">//修改最短路径但没入队的结点入队操作</span><br>                    q[tt++]=j;<br>                    <span class="hljs-keyword">if</span>(tt==N) tt=<span class="hljs-number">0</span>;<br>                    st[j]=<span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 需要判断是否所有牛都可以到达这处牧场!!!!!!!!</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-type">int</span> j=id[i];<br>        <span class="hljs-keyword">if</span>(dist[j]==INF)&#123;<br>            res=INF;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> res+=dist[j];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;p&gt;&gt;m;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;id[i];<br><br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> a,b,c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br><br>        <span class="hljs-built_in">add</span>(a,b,c),<span class="hljs-built_in">add</span>(b,a,c);<br>    &#125;<br><br>    <span class="hljs-type">int</span> res=INF;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=p;i++) res=<span class="hljs-built_in">min</span>(res, <span class="hljs-built_in">spfa</span>(i));<br><br>    cout&lt;&lt;res&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="信使"><a href="#信使" class="headerlink" title="信使"></a>信使</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://blog.csdn.net/xingchen_2008/article/details/129289330</span><br><span class="hljs-comment">// 这题属于单源最短路径，但数据较小，又因为弗洛伊德算法代码最简单，所以采用弗洛伊德</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">110</span>, INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> d[N][N];<br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>            <span class="hljs-keyword">if</span>(i==j) d[i][j]=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> d[i][j]=INF;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> a,b,c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br><br>        d[a][b]=d[b][a]=<span class="hljs-built_in">min</span>(d[a][b],c);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>                d[i][j]=<span class="hljs-built_in">min</span>(d[i][j],d[i][k]+d[k][j]);<br><br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">if</span>(d[<span class="hljs-number">1</span>][i]==INF)&#123;<br>            res=<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            res=<span class="hljs-built_in">max</span>(res,d[<span class="hljs-number">1</span>][i]);<br>        &#125;<br><br>    cout&lt;&lt;res&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最小花费"><a href="#最小花费" class="headerlink" title="最小花费"></a>最小花费</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://blog.csdn.net/Jacob0824/article/details/123061338</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * p=100*w1*w2*w3*...*wn</span><br><span class="hljs-comment"> * 可以看成单源最长路径（实际上和最短路径类似，但是要注意一些初始化的细节），</span><br><span class="hljs-comment"> * 累乘加一个取对数的步骤，可以变成累加，辅助理解，实际操作可以直接求乘积最大值</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 关于输入，一般规模超过十万（1e5）要采取scanf和printf</span><br><span class="hljs-comment"> * 需要适应一下</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2010</span>, M=<span class="hljs-number">1e5</span><span class="hljs-number">+10</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> S,T;<br><span class="hljs-type">double</span> g[N][N];<br><span class="hljs-type">double</span> dist[N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>&#123;<br>    dist[S]=<span class="hljs-number">1</span>;<span class="hljs-comment">//乘法零元是1</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-comment">//先找出目前没被遍历过的，值最大的结点</span><br>        <span class="hljs-type">int</span> t=<span class="hljs-number">-1</span>;   <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(!st[j]&amp;&amp;(t==<span class="hljs-number">-1</span>||dist[t]&lt;dist[j]))<br>                t=j;<br>        &#125;<br>        st[t]=<span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">//用这个结点去更新</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>            dist[j]=<span class="hljs-built_in">max</span>(dist[j], dist[t]*g[t][j]);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> a,b,c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);<br>        <span class="hljs-type">double</span> d=(<span class="hljs-number">100.0</span>-c)/<span class="hljs-number">100</span>;<span class="hljs-comment">//汇率</span><br>        <span class="hljs-comment">//这里可以注意一下每条边的权重范围是0~1，不同范围适用的算法会不太一样</span><br>        g[a][b]=g[b][a]=<span class="hljs-built_in">max</span>(d, g[a][b]);<br>    &#125;<br><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;S, &amp;T);<br><br>    <span class="hljs-built_in">dijkstra</span>();<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * &quot;lf&quot;表示double,</span><br><span class="hljs-comment">     * &quot;.8&quot;表示保留8位小数</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.8lf\n&quot;</span>, <span class="hljs-number">100</span>/dist[T]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最优乘车"><a href="#最优乘车" class="headerlink" title="最优乘车"></a>最优乘车</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://blog.csdn.net/qq_30277239/article/details/106148993</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M=<span class="hljs-number">110</span>, N=<span class="hljs-number">510</span>, INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> m,n;<br><span class="hljs-type">bool</span> g[N][N];<br><span class="hljs-type">int</span> stop[N];<br><span class="hljs-type">int</span> dist[N];<br><span class="hljs-type">int</span> q[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> hh=<span class="hljs-number">0</span>, tt=<span class="hljs-number">1</span>;<br>    q[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span>(hh!=tt)&#123;<br>        <span class="hljs-type">int</span> t=q[hh++];<br>        <span class="hljs-keyword">if</span>(hh==N) hh=<span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(g[t][i]&amp;&amp;dist[i]&gt;dist[t]<span class="hljs-number">+1</span>)&#123;<br>                dist[i]=dist[t]<span class="hljs-number">+1</span>;<br>                q[tt++]=i;<br>                <span class="hljs-keyword">if</span>(tt==N) tt=<span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;m&gt;&gt;n;<br><br>    string line;<br>    <span class="hljs-built_in">getline</span>(cin, line);<span class="hljs-comment">// 读取回车</span><br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-built_in">getline</span>(cin, line);<br><br>        <span class="hljs-function">stringstream <span class="hljs-title">ssin</span><span class="hljs-params">(line)</span></span>;<br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>,p;<br>        <span class="hljs-keyword">while</span>(ssin&gt;&gt;p) stop[cnt++]=p;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;cnt;i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">+1</span>;j&lt;cnt;j++)<span class="hljs-comment">//注意，这里是单程巴士线路</span><br>                g[stop[i]][stop[j]]=<span class="hljs-literal">true</span>;<br>    &#125;<br>     <br>    <span class="hljs-built_in">bfs</span>();<span class="hljs-comment">// 每条边的权重只能是0或者1，所以可以用bfs</span><br><br>    <span class="hljs-keyword">if</span>(dist[n]==INF) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;dist[n]<span class="hljs-number">-1</span>&lt;&lt;endl;<span class="hljs-comment">//换乘次数，等于坐的车辆数减1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="昂贵的聘礼"><a href="#昂贵的聘礼" class="headerlink" title="昂贵的聘礼"></a>昂贵的聘礼</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://blog.csdn.net/ju_ruo_ruo/article/details/125650770</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">110</span>, INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> m,n;<br><span class="hljs-type">int</span> w[N][N], l[N];<br><span class="hljs-type">int</span> dist[N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> down, <span class="hljs-type">int</span> up)</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    <span class="hljs-built_in">memset</span>(st, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> st);<br><br>    dist[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<span class="hljs-comment">//0作为起点，其实可以不考虑level，因为一定会遍历到，而且后续也不用修改dist</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-type">int</span> t=<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=n;j++)<br>            <span class="hljs-keyword">if</span>(!st[j]&amp;&amp;(t==<span class="hljs-number">-1</span>||dist[j]&lt;dist[t]))<br>                t=j;<br>        <br>        st[t]=<span class="hljs-literal">true</span>;<span class="hljs-comment">//判重！！！！</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=n;j++)<br>            <span class="hljs-keyword">if</span>(l[j]&gt;=down&amp;&amp;l[j]&lt;=up)<span class="hljs-comment">//判定是否在指定等级范围内</span><br>                dist[j]=<span class="hljs-built_in">min</span>(dist[j], dist[t]+w[t][j]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dist[<span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;m&gt;&gt;n;<br><br>    <span class="hljs-built_in">memset</span>(w, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> w);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-type">int</span> p,cnt;<br>        cin&gt;&gt;p&gt;&gt;l[i]&gt;&gt;cnt;<br>        w[<span class="hljs-number">0</span>][i]=<span class="hljs-built_in">min</span>(w[<span class="hljs-number">0</span>][i], p);<span class="hljs-comment">//0号作为虚拟起点</span><br><br>        <span class="hljs-keyword">while</span>(cnt--)&#123;<br>            <span class="hljs-type">int</span> t,v;<br>            cin&gt;&gt;t&gt;&gt;v;<br>            w[t][i]=<span class="hljs-built_in">min</span>(w[t][i], v);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 等级区间范围很小，所以我们可以遍历所有长度为2m，包含level[1]的小区间，求出最小值</span><br>    <span class="hljs-type">int</span> res=INF;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l[<span class="hljs-number">1</span>]-m;i&lt;=l[<span class="hljs-number">1</span>];i++) res=<span class="hljs-built_in">min</span>(res, <span class="hljs-built_in">dijkstra</span>(i,i+m));<br><br>    cout&lt;&lt;res&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>寒假练题计划</category>
      
      <category>提高算法</category>
      
      <category>图论</category>
      
      <category>单源最短路径</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>algorithm</tag>
      
      <tag>ACwing</tag>
      
      <tag>BFS</tag>
      
      <tag>Dijsktra</tag>
      
      <tag>SPFA</tag>
      
      <tag>Floyd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025-01-25区间合并</title>
    <link href="/2025/01/25/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/"/>
    <url>/2025/01/25/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p>快速地将一系列区间中有交集（包括端点相交）的区间合并成一个,返回处理后的区间列表。</p><p><img src="https://pic--oss.oss-cn-beijing.aliyuncs.com/img/image-20250125163700640.png" alt="image-20250125163700640"></p><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;PII&gt;&amp; segs)</span></span>&#123;<br>    vector&lt;PII&gt; res;<br><br>    <span class="hljs-built_in">sort</span>(segs.<span class="hljs-built_in">begin</span>(),segs.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//先按照左边界大小从小到大排序</span><br><br>    <span class="hljs-type">int</span> st=<span class="hljs-number">-2e9</span>,ed=<span class="hljs-number">-2e9</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> seg:segs)&#123;<br>        <span class="hljs-keyword">if</span>(ed&lt;seg.first)&#123;<br>            <span class="hljs-keyword">if</span>(ed!=<span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st,ed&#125;);<br>            st=seg.first,ed=seg.second;<br>        &#125;<br>        <span class="hljs-keyword">else</span> ed=<span class="hljs-built_in">max</span>(ed,seg.second);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(ed!=<span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st,ed&#125;);<span class="hljs-comment">//要记得把最后一段区间加到结果里</span><br><br>    segs=res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://blog.csdn.net/m0_51547272/article/details/135909456?ops_request_misc=%7B%22request_id%22:%22796a2b1beae2c61fb9d297b2969bf42b%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=796a2b1beae2c61fb9d297b2969bf42b&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-135909456-null-null.142%5Ev101%5Epc_search_result_base2&utm_term=acwing%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6&spm=1018.2226.3001.4187">Acwing区间合并_acwing 区间合并-CSDN博客</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://blog.csdn.net/m0_51547272/article/details/135909456</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">比题目严格的测试样例</span><br><span class="hljs-comment">Input:</span><br><span class="hljs-comment">5</span><br><span class="hljs-comment">7 9</span><br><span class="hljs-comment">2 4</span><br><span class="hljs-comment">5 6</span><br><span class="hljs-comment">1 2</span><br><span class="hljs-comment">7 8</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Output:</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br>vector&lt;PII&gt; segs;<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;PII&gt;&amp; segs)</span></span>&#123;<br>    vector&lt;PII&gt; res;<br><br>    <span class="hljs-built_in">sort</span>(segs.<span class="hljs-built_in">begin</span>(),segs.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//先按照左边界大小从小到大排序</span><br><br>    <span class="hljs-type">int</span> st=<span class="hljs-number">-2e9</span>,ed=<span class="hljs-number">-2e9</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> seg:segs)&#123;<br>        <span class="hljs-keyword">if</span>(ed&lt;seg.first)&#123;<br>            <span class="hljs-keyword">if</span>(ed!=<span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st,ed&#125;);<br>            st=seg.first,ed=seg.second;<br>        &#125;<br>        <span class="hljs-keyword">else</span> ed=<span class="hljs-built_in">max</span>(ed,seg.second);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(ed!=<span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st,ed&#125;);<span class="hljs-comment">//要记得把最后一段区间加到结果里</span><br><br>    segs=res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> l,r;<br>        cin&gt;&gt;l&gt;&gt;r;<br>        segs.<span class="hljs-built_in">push_back</span>(&#123;l,r&#125;);<br>    &#125;<br><br>    <span class="hljs-built_in">merge</span>(segs);<br><br>    cout&lt;&lt;segs.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>寒假练题计划</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>algorithm</tag>
      
      <tag>ACwing</tag>
      
      <tag>interval merging</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025-01-25离散化</title>
    <link href="/2025/01/25/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    <url>/2025/01/25/%E7%A6%BB%E6%95%A3%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p><img src="https://pic--oss.oss-cn-beijing.aliyuncs.com/img/image-20250125123839103.png" alt="image-20250125123839103"></p><h2 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; alls;<span class="hljs-comment">//存储所有待离散化的值</span><br><span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(),alls.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//将所有值排序</span><br>alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(),alls.<span class="hljs-built_in">end</span>()),alls.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//去重</span><br><br><span class="hljs-comment">//二分求出x对应的离散化下标</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=alls.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br><span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(alls[mid]&gt;=x) r=mid;<br>        <span class="hljs-keyword">else</span> l=mid<span class="hljs-number">+1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l<span class="hljs-number">+1</span>;<span class="hljs-comment">//下标从1开始</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a>区间和</h3><p><a href="https://blog.csdn.net/2301_80072871/article/details/140408415?ops_request_misc=%7B%22request_id%22:%226eef23061a73e6a0c727b98dac6c809a%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=6eef23061a73e6a0c727b98dac6c809a&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-140408415-null-null.142%5Ev101%5Epc_search_result_base2&utm_term=acwing%E5%8C%BA%E9%97%B4%E5%92%8C&spm=1018.2226.3001.4187">Acwing基础算法 802. 区间和_acwing 802. 区间和-CSDN博客</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://blog.csdn.net/2301_80072871/article/details/140408415</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e5</span><span class="hljs-number">+5</span>;<br><span class="hljs-type">int</span> a[N],sum[N];<br><span class="hljs-type">int</span> n,m;<br>vector&lt;PII&gt; add;<br>vector&lt;PII&gt; query;<br>vector&lt;<span class="hljs-type">int</span>&gt; alls;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=alls.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>        <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(alls[mid]&gt;=x) r=mid;<span class="hljs-comment">//[l,mid]</span><br>        <span class="hljs-keyword">else</span> l=mid<span class="hljs-number">+1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> l<span class="hljs-number">+1</span>;<span class="hljs-comment">//因为涉及前缀和，所以映射下标从1开始</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> x,c;<br>        cin&gt;&gt;x&gt;&gt;c;<br>        add.<span class="hljs-built_in">push_back</span>(&#123;x,c&#125;);<br>        alls.<span class="hljs-built_in">push_back</span>(x);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> l,r;<br>        cin&gt;&gt;l&gt;&gt;r;<br>        query.<span class="hljs-built_in">push_back</span>(&#123;l,r&#125;);<br>        alls.<span class="hljs-built_in">push_back</span>(l);<br>        alls.<span class="hljs-built_in">push_back</span>(r);<br>    &#125;<br><br>    <span class="hljs-comment">//排序，去重</span><br>    <span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(),alls.<span class="hljs-built_in">end</span>());<br>    alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(),alls.<span class="hljs-built_in">end</span>()),alls.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> item:add) a[<span class="hljs-built_in">find</span>(item.first)]+=item.second;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=alls.<span class="hljs-built_in">size</span>();i++) sum[i]=sum[i<span class="hljs-number">-1</span>]+a[i];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> item:query) cout&lt;&lt;sum[<span class="hljs-built_in">find</span>(item.second)]-sum[<span class="hljs-built_in">find</span>(item.first)<span class="hljs-number">-1</span>]&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>寒假练题计划</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>algorithm</tag>
      
      <tag>ACwing</tag>
      
      <tag>discretization</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025-01-25位运算</title>
    <link href="/2025/01/25/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2025/01/25/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><h3 id="low-bit"><a href="#low-bit" class="headerlink" title="low_bit"></a>low_bit</h3><p>返回的是一个整数的二进制形式最右边的“1”，比如对于(101011000)<sub>2</sub></p><p>返回的是(1000)<sub>2</sub></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">low_bit</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> n&amp;-n;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="low-bit-1"><a href="#low-bit-1" class="headerlink" title="low_bit"></a>low_bit</h3><p>二进制表示中1的个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">low_bit</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    可以得到整数二进制形式的最右边的&#x27;1&#x27;</span><br><span class="hljs-comment">    比如(101101000)2</span><br><span class="hljs-comment">    得到(1000)2 也就是8</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">return</span> n&amp;-n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br><br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(n) cnt++,n-=<span class="hljs-built_in">low_bit</span>(n); <br>    cout&lt;&lt;cnt&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>寒假练题计划</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>algorithm</tag>
      
      <tag>ACwing</tag>
      
      <tag>binary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025-01-24双指针</title>
    <link href="/2025/01/24/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <url>/2025/01/24/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h1 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p>双指针有很多种，第一类是两个指针在不同的序列上，比如归并排序的区间合并问题，还有一类是两个指针指向同一序列的不同位置来解决一些问题。主要遇到的是第二类。</p><p>针对<code>第二类</code>，一般可套用下面的<code>模板</code>。双指针实质上是根据问题的<code>某种特性</code>，比如单调性，来对<code>朴素算法</code>进行<code>优化</code>。</p><p><img src="https://pic--oss.oss-cn-beijing.aliyuncs.com/img/image-20250124200853222.png" alt="image-20250124200853222"></p><h2 id="经典例题"><a href="#经典例题" class="headerlink" title="经典例题"></a>经典例题</h2><h3 id="A-B"><a href="#A-B" class="headerlink" title="A+B"></a>A+B</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">Input:</span><br><span class="hljs-comment">abs fadsa dsadsa</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Output:</span><br><span class="hljs-comment">abs</span><br><span class="hljs-comment">fadsa</span><br><span class="hljs-comment">dsadsa</span><br><span class="hljs-comment">*/</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    string s;<br>    <span class="hljs-built_in">getline</span>(cin,s);<br><br>    <span class="hljs-type">int</span> n=s.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> j=i;<br>        <span class="hljs-keyword">while</span>(j&lt;n&amp;&amp;s[j]!=<span class="hljs-string">&#x27; &#x27;</span>) j++;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i;k&lt;j;k++) cout&lt;&lt;s[k];<br>        cout&lt;&lt;endl;<br><br>        i=j;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长连续不重复子序列"><a href="#最长连续不重复子序列" class="headerlink" title="最长连续不重复子序列"></a>最长连续不重复子序列</h3><ul><li><p>j表示以i结尾的<code>最长连续不重复子序列</code>的最左下标。</p></li><li><p>这里要抓住问题的<code>单调性</code>：当i向右走的时候，j只能向右走或者原地不动。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">整数在N范围内</span><br><span class="hljs-comment">Input:</span><br><span class="hljs-comment">5</span><br><span class="hljs-comment">1 2 2 3 5</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Output:</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> s[N];<span class="hljs-comment">//记录目前[j,i]区间内某个整数出现的次数 </span><br><span class="hljs-type">int</span> n;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];<br><br>    <span class="hljs-type">int</span> mx=<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        s[a[i]]++;<br>        <span class="hljs-keyword">while</span>(s[a[i]]&gt;<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//while(j&lt;i&amp;&amp;s[a[i]]&gt;1)</span><br>            s[a[j]]--;<br>            j++;<br>        &#125;<br><br>        mx=<span class="hljs-built_in">max</span>(mx,i-j<span class="hljs-number">+1</span>);<br>    &#125;<br><br>    cout&lt;&lt;mx&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>寒假练题计划</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>algorithm</tag>
      
      <tag>ACwing</tag>
      
      <tag>double-pointer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025-01-23差分</title>
    <link href="/2025/01/23/%E5%B7%AE%E5%88%86/"/>
    <url>/2025/01/23/%E5%B7%AE%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><h2 id="情景"><a href="#情景" class="headerlink" title="情景"></a>情景</h2><p>将区间[l,r]之间每个元素都加上一个数c，求修改后数组的值。</p><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><h3 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h3><p><img src="https://pic--oss.oss-cn-beijing.aliyuncs.com/img/image-20250123190723456.png" alt="image-20250123190723456"></p><h3 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h3><p><img src="https://pic--oss.oss-cn-beijing.aliyuncs.com/img/image-20250124103958573.png" alt="image-20250124103958573"></p><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><h3 id="一维差分-1"><a href="#一维差分-1" class="headerlink" title="一维差分"></a>一维差分</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,q;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> diff[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> x)</span></span>&#123;<br>    diff[l]+=x;<br>    diff[r<span class="hljs-number">+1</span>]-=x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">insert</span>(i,i,a[i]);<span class="hljs-comment">//初始化,把a[i]加到第i个位置上</span><br><br>    <span class="hljs-keyword">while</span>(q--)&#123;<br>        <span class="hljs-type">int</span> l,r,c;<br>        cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;<br><br>        <span class="hljs-built_in">insert</span>(l,r,c);<br>    &#125;<br><br>    <span class="hljs-type">int</span> pre=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        pre=diff[i]+pre;<br>        cout&lt;&lt;pre&lt;&lt;endl;<br>    &#125; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二维差分-1"><a href="#二维差分-1" class="headerlink" title="二维差分"></a>二维差分</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,m,q;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1005</span>;<br><span class="hljs-type">int</span> diff[N][N],sum[N][N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x1,<span class="hljs-type">int</span> y1,<span class="hljs-type">int</span> x2,<span class="hljs-type">int</span> y2,<span class="hljs-type">int</span> c)</span></span>&#123;<br>    diff[x1][y1]+=c;<br>    diff[x1][y2<span class="hljs-number">+1</span>]-=c;<br>    diff[x2<span class="hljs-number">+1</span>][y1]-=c;<br>    diff[x2<span class="hljs-number">+1</span>][y2<span class="hljs-number">+1</span>]+=c;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            <span class="hljs-type">int</span> a;<br>            cin&gt;&gt;a;<br>            <span class="hljs-built_in">insert</span>(i,j,i,j,a);<br>        &#125;<br><br>    <span class="hljs-keyword">while</span>(q--)&#123;<br>        <span class="hljs-type">int</span> x1,y1,x2,y2,c;<br>        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;c;<br><br>        <span class="hljs-built_in">insert</span>(x1,y1,x2,y2,c);<br>            <br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            sum[i][j]=diff[i][j]+sum[i<span class="hljs-number">-1</span>][j]+sum[i][j<span class="hljs-number">-1</span>]-sum[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>            cout&lt;&lt;sum[i][j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout&lt;&lt;endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>寒假练题计划</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>algorithm</tag>
      
      <tag>ACwing</tag>
      
      <tag>differential</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025-01-23前缀和</title>
    <link href="/2025/01/23/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    <url>/2025/01/23/%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><h2 id="情景"><a href="#情景" class="headerlink" title="情景"></a>情景</h2><p>求区间[l,r]之间所有元素的和。</p><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><h3 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h3><p><img src="https://pic--oss.oss-cn-beijing.aliyuncs.com/img/image-20250123181901668.png" alt="image-20250123181901668"></p><h3 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h3><p><img src="https://pic--oss.oss-cn-beijing.aliyuncs.com/img/image-20250123183813888.png" alt="image-20250123183813888"></p><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><p><a href="https://blog.csdn.net/qq_44426403/article/details/134255195">https://blog.csdn.net/qq_44426403/article/details/134255195</a></p><h3 id="一维前缀和-1"><a href="#一维前缀和-1" class="headerlink" title="一维前缀和"></a>一维前缀和</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>;<br><span class="hljs-type">int</span> sum[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-type">int</span> pre=<span class="hljs-number">0</span>,a;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;a;<br>        sum[i]=a+pre;<br>        pre=sum[i];<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> l,r;<br>        cin&gt;&gt;l&gt;&gt;r;<br>        cout&lt;&lt;sum[r]-sum[l<span class="hljs-number">-1</span>]&lt;&lt;endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二维前缀和-1"><a href="#二维前缀和-1" class="headerlink" title="二维前缀和"></a>二维前缀和</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,m,q;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1005</span>;<br><span class="hljs-type">int</span> sum[N][N];<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            <span class="hljs-type">int</span> a;<br>            cin&gt;&gt;a;<br>            sum[i][j]=a+sum[i][j<span class="hljs-number">-1</span>]+sum[i<span class="hljs-number">-1</span>][j]-sum[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>        &#125;<br>            <br>    <span class="hljs-keyword">while</span>(q--)&#123;<br>        <span class="hljs-type">int</span> x1,y1,x2,y2;<span class="hljs-comment">//左上和右下</span><br>        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;<br><br>        cout&lt;&lt;sum[x2][y2]-sum[x1<span class="hljs-number">-1</span>][y2]-sum[x2][y1<span class="hljs-number">-1</span>]+sum[x1<span class="hljs-number">-1</span>][y1<span class="hljs-number">-1</span>]&lt;&lt;endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>寒假练题计划</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>algorithm</tag>
      
      <tag>ACwing</tag>
      
      <tag>prefix sum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>csp36-5 梦魔(30分)</title>
    <link href="/2025/01/23/%E6%A2%A6%E9%AD%94/"/>
    <url>/2025/01/23/%E6%A2%A6%E9%AD%94/</url>
    
    <content type="html"><![CDATA[<h1 id="csp36-5-梦魔"><a href="#csp36-5-梦魔" class="headerlink" title="csp36-5 梦魔"></a>csp36-5 梦魔</h1><h2 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h2><p><a href="https://sim.csp.thusaac.com/contest/36/problem/4">https://sim.csp.thusaac.com/contest/36/problem/4</a></p><h2 id="30分作答"><a href="#30分作答" class="headerlink" title="30分作答"></a>30分作答</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,q;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e6</span><span class="hljs-number">+5</span>;<br><span class="hljs-type">int</span> a[N],b[N];<br><br><span class="hljs-type">int</span> a_new[N],b_new[N];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> bb,<span class="hljs-type">int</span> i)</span></span>&#123;<span class="hljs-comment">//n个int相加会溢出，所以用long long</span><br>    <span class="hljs-type">int</span> l=i,r=i<span class="hljs-number">+1</span>;<br>    <span class="hljs-keyword">while</span>(l&gt;=<span class="hljs-number">0</span>&amp;&amp;r&lt;n)&#123;<br>        <span class="hljs-keyword">if</span>(a_new[l]&lt;=a_new[r])&#123;<br>            <span class="hljs-keyword">if</span>(bb&lt;a_new[l]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">else</span>&#123;<br>                bb+=b_new[l];<br>                l--;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(bb&lt;a_new[r]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">else</span>&#123;<br>                bb+=b_new[r];<br>                r++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(l&gt;=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(bb&lt;a_new[l]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span>&#123;<br>            bb+=b_new[l];<br>            l--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(r&lt;n)&#123;<br>        <span class="hljs-keyword">if</span>(bb&lt;a_new[r]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span>&#123;<br>            bb+=b_new[r];<br>            r++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;b[i];<br><br>    cin&gt;&gt;q;<br>    <span class="hljs-keyword">while</span>(q--)&#123;<br>        <span class="hljs-type">int</span> k;<br>        cin&gt;&gt;k;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            a_new[i]=a[i];<br>            b_new[i]=b[i];<br>        &#125; <br><br>        <span class="hljs-keyword">while</span>(k--)&#123;<span class="hljs-comment">//变动</span><br>            <span class="hljs-type">int</span> j,aa,bb;<br>            cin&gt;&gt;j&gt;&gt;aa&gt;&gt;bb;<br>            a_new[j<span class="hljs-number">-1</span>]=aa;<br>            b_new[j<span class="hljs-number">-1</span>]=bb;<br>        &#125;<br><br>        <span class="hljs-comment">//设计让a的最大值作为二分的右边界</span><br>        <span class="hljs-type">int</span> amax=<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) amax=<span class="hljs-built_in">max</span>(amax,a_new[i]);<br><br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>            <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=amax;<br>            <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>                <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid,i)) r=mid;<span class="hljs-comment">//[l,mid]</span><br>                <span class="hljs-keyword">else</span> l=mid<span class="hljs-number">+1</span>;<br>            &#125;<br>            <span class="hljs-comment">// cout&lt;&lt;&quot;p:&quot;&lt;&lt;l&lt;&lt;endl;</span><br>            ans^=l;<br>        &#125;<br><br>        cout&lt;&lt;ans&lt;&lt;endl;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>寒假练题计划</category>
      
      <category>scp认证真题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>algorithm</tag>
      
      <tag>binary search</tag>
      
      <tag>csp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025-01-22高精度整数运算</title>
    <link href="/2025/01/22/%E9%AB%98%E7%B2%BE%E5%BA%A6%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/"/>
    <url>/2025/01/22/%E9%AB%98%E7%B2%BE%E5%BA%A6%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="高精度整数运算"><a href="#高精度整数运算" class="headerlink" title="高精度整数运算"></a>高精度整数运算</h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>为了解决cpp语言整型变量存在范围，太大的整数会导致溢出。</p><h2 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h2><ul><li><p>采用vector存储每一位数，一般从低位开始存，方便进位操作。</p></li><li><p>加法、减法、乘法都是从最低位算起的，但是除法得从最高位算起，保存的C数组也是反的，所以返回之前要转置。</p></li></ul><h2 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h2><p>两个大整数相加。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span><span class="hljs-number">+10</span>;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;A,vector&lt;<span class="hljs-type">int</span>&gt;&amp;B)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;C;<br><br>    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>()||i&lt;B.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;A.<span class="hljs-built_in">size</span>()) t+=A[i];<br>        <span class="hljs-keyword">if</span>(i&lt;B.<span class="hljs-built_in">size</span>()) t+=B[i];<br><br>        C.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(t) C.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//容易忘记!!!!</span><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    string a,b;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A,B;<br><br>    cin&gt;&gt;a&gt;&gt;b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) B.<span class="hljs-built_in">push_back</span>(b[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<span class="hljs-comment">//字符化数字</span><br><br>    <span class="hljs-keyword">auto</span> C=<span class="hljs-built_in">add</span>(A,B);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) cout&lt;&lt;C[i];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h2><p>两个大整数相减</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;A,vector&lt;<span class="hljs-type">int</span>&gt;&amp;B)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(A.<span class="hljs-built_in">size</span>()!=B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>()&gt;B.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=A.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">if</span>(A[i]!=B[i]) <span class="hljs-keyword">return</span> A[i]&gt;B[i];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;A,vector&lt;<span class="hljs-type">int</span>&gt;&amp;B)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,t=<span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>();i++)&#123;<br>        t=A[i]-t;<br>        <span class="hljs-keyword">if</span>(i&lt;B.<span class="hljs-built_in">size</span>()) t-=B[i];<br><br>        C.<span class="hljs-built_in">push_back</span>((t<span class="hljs-number">+10</span>)%<span class="hljs-number">10</span>);<br><br>        <span class="hljs-keyword">if</span>(t&lt;<span class="hljs-number">0</span>) t=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> t=<span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;C.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//去除前导0</span><br><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    string a,b;<br>    vector&lt;<span class="hljs-type">int</span>&gt;A,B;<br><br>    cin&gt;&gt;a&gt;&gt;b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) B.<span class="hljs-built_in">push_back</span>(b[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cmp</span>(A,B))&#123;<span class="hljs-comment">//要确保大数减小数</span><br>        <span class="hljs-keyword">auto</span> C=<span class="hljs-built_in">sub</span>(A,B);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) cout&lt;&lt;C[i];<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">auto</span> C=<span class="hljs-built_in">sub</span>(B,A);<br>        cout&lt;&lt;<span class="hljs-string">&quot;-&quot;</span>;<span class="hljs-comment">//结果的负号单独先输出</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) cout&lt;&lt;C[i];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h2><p>一个大整数乘一个小整数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;A,<span class="hljs-type">int</span>&amp; n)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br><br>    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>();i++)&#123;<br>        t=t+A[i]*n;<br>        C.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(t&gt;<span class="hljs-number">0</span>) C.<span class="hljs-built_in">push_back</span>(t);<br><br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;C.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    string a;<br>    cin&gt;&gt;a;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt;A;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br><br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br><br>    <span class="hljs-keyword">auto</span> C=<span class="hljs-built_in">mul</span>(A,n);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) cout&lt;&lt;C[i];<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h2><p>一个大整数除以一个小整数，要返回商和余数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;A, <span class="hljs-type">int</span>&amp; n,<span class="hljs-type">int</span>&amp; r)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=A.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<span class="hljs-comment">//从高位开始除</span><br>        r=r*<span class="hljs-number">10</span>+A[i];<br>        C.<span class="hljs-built_in">push_back</span>(r/n);<br>        r%=n;<br>    &#125;<br><br>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(),C.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//倒置得到答案</span><br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;C.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//去除前导0</span><br><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    string a;<br>    <span class="hljs-type">int</span> n;<br><br>    cin&gt;&gt;a&gt;&gt;n;<br>    vector&lt;<span class="hljs-type">int</span>&gt;A;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br><br>    <span class="hljs-type">int</span> r=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">auto</span> C=<span class="hljs-built_in">div</span>(A,n,r);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) cout&lt;&lt;C[i];<br>    cout&lt;&lt;endl&lt;&lt;r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>寒假练题计划</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>algorithm</tag>
      
      <tag>ACwing</tag>
      
      <tag>big integer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025-01-20浮点二分</title>
    <link href="/2025/01/20/2025-1-20%E6%B5%AE%E7%82%B9%E4%BA%8C%E5%88%86/"/>
    <url>/2025/01/20/2025-1-20%E6%B5%AE%E7%82%B9%E4%BA%8C%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="浮点二分"><a href="#浮点二分" class="headerlink" title="浮点二分"></a>浮点二分</h1><p>浮点二分比整数二分简单得多，因为无需判断边界条件，只要设置精度即可。</p><ul><li>设置精度标准：一般题目要求保留x位的话，精度加上2没有大问题。</li></ul><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-9</span>;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-type">double</span> left, <span class="hljs-type">double</span> right)</span> </span>&#123;<br>    <span class="hljs-type">int</span> l=left, r=right;<br>    <span class="hljs-keyword">while</span> (r-l &gt; eps) &#123;<br>        <span class="hljs-type">double</span> mid = (l+r)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><p>#例题<br>求立方根</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> x;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> P=<span class="hljs-number">1e-2</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;x;<br>    <span class="hljs-type">double</span> l=<span class="hljs-number">0</span>,r=<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>;<br>    <span class="hljs-keyword">while</span>(r-l&gt;P)&#123;<br>        <span class="hljs-type">double</span> mid=(r+l)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(mid*mid*mid&lt;=x) l=mid;<br>        <span class="hljs-keyword">else</span> r=mid;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> ans=r;<br>    cout&lt;&lt;<span class="hljs-string">&quot;l: &quot;</span>&lt;&lt;l&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;r: &quot;</span>&lt;&lt;r&lt;&lt;endl;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>寒假练题计划</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>algorithm</tag>
      
      <tag>ACwing</tag>
      
      <tag>binary search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025-01-19二分</title>
    <link href="/2025/01/19/2025-1-19%E4%BA%8C%E5%88%86/"/>
    <url>/2025/01/19/2025-1-19%E4%BA%8C%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-comment">//判断函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-comment">//[l,mid],[mid+1,r]</span><br><span class="hljs-type">int</span> <span class="hljs-built_in">bsearch_1</span>(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)&#123;<br>    <span class="hljs-keyword">while</span> (l&lt;r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) r=mid;<br>        <span class="hljs-keyword">else</span> l=mid<span class="hljs-number">+1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;   <br>&#125;<br><br><span class="hljs-comment">//[l,mid-1],[mid,r]</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_2</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>        <span class="hljs-type">int</span> mid=l+r<span class="hljs-number">+1</span>&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) l=mid;<br>        <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://blog.csdn.net/qq_43738331/article/details/109460567">数的范围</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,q,x;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check_1</span><span class="hljs-params">(<span class="hljs-type">int</span> mid)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a[mid]&gt;=x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check_2</span><span class="hljs-params">(<span class="hljs-type">int</span> mid)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a[mid]&lt;=x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-keyword">while</span>(q--)&#123;<br>        cin&gt;&gt;x;<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check_1</span>(mid)) r=mid;<br>            <span class="hljs-keyword">else</span> l=mid<span class="hljs-number">+1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> sta=l;<span class="hljs-comment">//第一个大于等于x的数</span><br><br>        l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-type">int</span> mid=l+r<span class="hljs-number">+1</span>&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check_2</span>(mid)) l=mid;<br>            <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> end=l;<span class="hljs-comment">//第一个小于等于x的数</span><br><br>        <span class="hljs-keyword">if</span>(a[sta]!=x||a[end]!=x) cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;sta&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;end&lt;&lt;endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P8647">P8647  蓝桥杯 2017 省 AB 分巧克力 - 洛谷 | 计算机科学教育新生态</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,k;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>;<br><span class="hljs-type">int</span> a[N],b[N];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> mid)</span></span>&#123;<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//这里必须切整块的正方形，边角料不要，有点逆天</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) sum+=(a[i]/mid)*(b[i]/mid);<br>    <span class="hljs-keyword">return</span> sum&gt;=k;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;a[i]&gt;&gt;b[i];<br>    &#125;<br><br>    <span class="hljs-comment">//模板</span><br>    <span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,r=N;<br>    <span class="hljs-keyword">while</span> (l&lt;r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid=l+r<span class="hljs-number">+1</span>&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) l=mid;<span class="hljs-comment">//[mid,r]</span><br>        <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    cout&lt;&lt;l&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>寒假练题计划</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>algorithm</tag>
      
      <tag>ACwing</tag>
      
      <tag>binary search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025-01-18归并排序</title>
    <link href="/2025/01/18/2025-1-18%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2025/01/18/2025-1-18%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>;<br><span class="hljs-type">int</span> a[N],tmp[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ms</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br><br>    <span class="hljs-built_in">ms</span>(l,mid);<br>    <span class="hljs-built_in">ms</span>(mid<span class="hljs-number">+1</span>,r);<br><br>    <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>,i=l,j=mid<span class="hljs-number">+1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)<br>        <span class="hljs-keyword">if</span>(a[i]&lt;a[j]) tmp[k++]=a[i++];<br>        <span class="hljs-keyword">else</span> tmp[k++]=a[j++];<br><br>    <span class="hljs-keyword">while</span>(i&lt;=mid) tmp[k++]=a[i++];<br>    <span class="hljs-keyword">while</span>(j&lt;=r) tmp[k++]=a[j++];<br><br>    <span class="hljs-keyword">for</span>(i=l,j=<span class="hljs-number">0</span>;i&lt;=r;i++,j++) a[i]=tmp[j];<br>&#125;<br><br><span class="hljs-built_in">ms</span>(<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br></code></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.com.cn/problem/P1177">P1177 【模板】排序 - 洛谷 | 计算机科学教育新生态</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>;<br><span class="hljs-type">int</span> a[N],tmp[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ms</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br><br>    <span class="hljs-built_in">ms</span>(l,mid);<br>    <span class="hljs-built_in">ms</span>(mid<span class="hljs-number">+1</span>,r);<br><br>    <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>,i=l,j=mid<span class="hljs-number">+1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)<br>        <span class="hljs-keyword">if</span>(a[i]&lt;a[j]) tmp[k++]=a[i++];<br>        <span class="hljs-keyword">else</span> tmp[k++]=a[j++];<br><br>    <span class="hljs-keyword">while</span>(i&lt;=mid) tmp[k++]=a[i++];<br>    <span class="hljs-keyword">while</span>(j&lt;=r) tmp[k++]=a[j++];<br><br>    <span class="hljs-keyword">for</span>(i=l,j=<span class="hljs-number">0</span>;i&lt;=r;i++,j++) a[i]=tmp[j];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-built_in">ms</span>(<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>寒假练题计划</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>algorithm</tag>
      
      <tag>ACwing</tag>
      
      <tag>sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025-01-18快速排序</title>
    <link href="/2025/01/18/2025-1-18%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2025/01/18/2025-1-18%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">qs</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//判断递归退出</span><br><span class="hljs-type">int</span> x=a[(l+r)/<span class="hljs-number">2</span>],i=l<span class="hljs-number">-1</span>,j=r<span class="hljs-number">+1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;j)&#123;<br><span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(a[i]&lt;x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(a[j]&gt;x);<br>        <span class="hljs-keyword">if</span>(i&lt;j) <span class="hljs-built_in">swap</span>(a[i],a[j]);<br>    &#125;<br>    <span class="hljs-built_in">qs</span>(l,j);<span class="hljs-comment">//注意j不能漏</span><br>    <span class="hljs-built_in">qs</span>(j<span class="hljs-number">+1</span>,r);<br>&#125;<br><br><span class="hljs-built_in">qs</span>(<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br></code></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://blog.csdn.net/qq_52384627/article/details/118654146">【1.基础算法-模板】1.快速排序 （模板）_快速排序算法模板-CSDN博客</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//快速排序</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">qs</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">return</span>;<br><span class="hljs-type">int</span> x=a[(l+r)/<span class="hljs-number">2</span>],i=l<span class="hljs-number">-1</span>,j=r<span class="hljs-number">+1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;j)&#123;<br><span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(a[i]&lt;x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(a[j]&gt;x);<br>        <span class="hljs-keyword">if</span>(i&lt;j) <span class="hljs-built_in">swap</span>(a[i],a[j]);<br>    &#125;<br>    <span class="hljs-built_in">qs</span>(l,j);<br>    <span class="hljs-built_in">qs</span>(j<span class="hljs-number">+1</span>,r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-built_in">qs</span>(<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//第k个数</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, k;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find_k</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r)<br>        <span class="hljs-keyword">return</span> a[l];<br>    <span class="hljs-type">int</span> x = a[l + (r - l) / <span class="hljs-number">2</span>], i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span><br>            i++;<br>        <span class="hljs-keyword">while</span> (a[i] &lt; x);<br>        <span class="hljs-keyword">do</span><br>            j--;<br>        <span class="hljs-keyword">while</span> (a[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j)<br>            <span class="hljs-built_in">swap</span>(a[i], a[j]);<br>    &#125;<br><br>    <span class="hljs-type">int</span> len = j - l + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (len &gt;= k)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find_k</span>(l, j, k);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find_k</span>(j + <span class="hljs-number">1</span>, r, k - len);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        cin &gt;&gt; a[i];<br>    <span class="hljs-type">int</span> find = <span class="hljs-built_in">find_k</span>(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, k);<br>    cout &lt;&lt; find &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>寒假练题计划</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>algorithm</tag>
      
      <tag>ACwing</tag>
      
      <tag>sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>寒假题单</title>
    <link href="/2025/01/18/%E5%AF%92%E5%81%87%E9%A2%98%E5%8D%95/"/>
    <url>/2025/01/18/%E5%AF%92%E5%81%87%E9%A2%98%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h2 id="ACWing基础大全"><a href="#ACWing基础大全" class="headerlink" title=" ACWing基础大全"></a> ACWing基础大全</h2><h3 id="第一讲-基础算法完成情况：20-20"><a href="#第一讲-基础算法完成情况：20-20" class="headerlink" title="第一讲 基础算法完成情况：20&#x2F;20"></a>第一讲 基础算法完成情况：20&#x2F;20</h3><blockquote><p>包括排序、二分、高精度、<a href="https://so.csdn.net/so/search?q=%E5%89%8D%E7%BC%80%E5%92%8C&spm=1001.2101.3001.7020">前缀和</a>与差分、双指针算法、位运算、离散化、区间合并等内容。</p></blockquote><p><strong>快速排序</strong><br><a href="https://blog.csdn.net/qq_52384627/article/details/118654146">AcWing 785. 快速排序<br>AcWing 786. 第k个数</a><br><strong>归并排序</strong><br><a href="https://blog.csdn.net/qq_52384627/article/details/118660064">AcWing 787. 归并排序<br>AcWing 788. 逆序对的数量</a><br><strong>二分</strong><br><a href="https://blog.csdn.net/qq_52384627/article/details/118667774">AcWing 789. 数的范围<br>AcWing 790. 数的三次方根</a><br><strong>高精度</strong><br><a href="https://blog.csdn.net/qq_52384627/article/details/118670433">AcWing 791. 高精度加法<br>AcWing 792. 高精度减法<br>AcWing 793. 高精度乘法<br>AcWing 794. 高精度除法</a><br><strong>前缀和与差分</strong><br><a href="https://blog.csdn.net/qq_52384627/article/details/118686274">AcWing 795. 前缀和<br>AcWing 796. 子矩阵的和<br>AcWing 797. 差分<br>AcWing 798. 差分矩阵</a><br><strong>双指针算法</strong><br><a href="https://blog.csdn.net/qq_52384627/article/details/118707026">AcWing 799. 最长连续不重复子序列<br>AcWing 800. 数组元素的目标和<br>AcWing 2816. 判断子序列</a><br><strong>位运算</strong><br><a href="https://blog.csdn.net/qq_52384627/article/details/118710468">AcWing 801. 二进制中1的个数</a><br><strong>离散化</strong><br><a href="https://blog.csdn.net/qq_52384627/article/details/118724866">AcWing 802. 区间和</a><br><strong>区间合并</strong><br><a href="https://blog.csdn.net/qq_52384627/article/details/118732585">AcWing 803. 区间合并</a></p><h3 id="第二讲-数据结构完成情况：17-17"><a href="#第二讲-数据结构完成情况：17-17" class="headerlink" title="第二讲 数据结构完成情况：17&#x2F;17"></a>第二讲 数据结构完成情况：17&#x2F;17</h3><blockquote><p>包括单链表，双链表，栈，队列，单调栈，单调队列，KMP，Trie，并查集，堆，哈希表等内容。</p></blockquote><p><strong>单链表</strong><br><a href="https://blog.csdn.net/qq_52384627/article/details/119541898">AcWing 826. 单链表</a><br><strong>双链表</strong><br><a href="https://blog.csdn.net/qq_52384627/article/details/119542056">AcWing 827. 双链表</a><br><strong>栈</strong><br><a href="https://blog.csdn.net/qq_52384627/article/details/119542270">AcWing 828. 模拟栈<br>AcWing 3302. 表达式求值</a><br><strong>队列</strong><br><a href="https://blog.csdn.net/qq_52384627/article/details/119542343">AcWing 829. 模拟队列</a><br><strong>单调栈</strong><br><a href="https://blog.csdn.net/qq_52384627/article/details/119542485">AcWing 830. 单调栈</a><br><strong>单调队列</strong><br><a href="https://blog.csdn.net/qq_52384627/article/details/119544279">AcWing 154. 滑动窗口</a><br><strong>KMP</strong><br><a href="https://blog.csdn.net/qq_52384627/article/details/119544315">AcWing 831. KMP字符串</a><br><strong>Trie</strong><br><a href="https://blog.csdn.net/qq_52384627/article/details/119544335">AcWing 835. Trie字符串统计<br>AcWing 143. 最大异或对</a><br><strong>并查集</strong><br><a href="https://blog.csdn.net/qq_52384627/article/details/119544427">AcWing 836. 合并集合<br>AcWing 837. 连通块中点的数量<br>AcWing 240. 食物链</a><br><strong>堆</strong><br><a href="https://blog.csdn.net/qq_52384627/article/details/119544487">AcWing 838. 堆排序<br>AcWing 839. 模拟堆</a><br><strong>哈希表</strong><br><a href="https://blog.csdn.net/qq_52384627/article/details/119546833">AcWing 840. 模拟散列表<br>AcWing 841. 字符串哈希</a></p><h3 id="第三讲-搜索与图论完成情况：17-17"><a href="#第三讲-搜索与图论完成情况：17-17" class="headerlink" title="第三讲 搜索与图论完成情况：17&#x2F;17"></a>第三讲 搜索与图论完成情况：17&#x2F;17</h3><blockquote><p>包括DFS，BFS，树与图的深度优先遍历，树与图的广度优先遍历，拓扑排序，Dijkstra，bellman-ford，spfa，Floyd，Prim，Kruskal，染色法判定二分图，匈牙利算法等内容。</p></blockquote><p>DFS<br>AcWing 842. 排列数字<br>AcWing 843. n-皇后问题<br>BFS<br>AcWing 844. 走迷宫<br>AcWing 845. 八数码<br>树与图的深度优先遍历<br>AcWing 846. 树的重心<br>树与图的广度优先遍历<br>AcWing 847. 图中点的层次<br>拓扑排序<br>AcWing 848. 有向图的拓扑序列<br>Dijkstra<br>AcWing 849. Dijkstra求最短路 I<br>AcWing 850. Dijkstra求最短路 II<br>bellman-ford<br>AcWing 853. 有边数限制的最短路<br>spfa<br>AcWing 851. spfa求最短路<br>AcWing 852. spfa判断负环<br>Floyd<br>AcWing 854. Floyd求最短路<br>Prim<br>AcWing 858. Prim算法求最小生成树<br>Kruskal<br>AcWing 859. Kruskal算法求最小生成树<br>染色法判定二分图<br>AcWing 860. 染色法判定二分图<br>匈牙利算法<br>AcWing 861. 二分图的最大匹配</p><h3 id="第四讲-数学知识完成情况：26-26"><a href="#第四讲-数学知识完成情况：26-26" class="headerlink" title="第四讲 数学知识完成情况：26&#x2F;26"></a>第四讲 数学知识完成情况：26&#x2F;26</h3><blockquote><p>包括质数，约数，欧拉函数，快速幂，扩展欧几里得算法，中国剩余定理，高斯消元，求组合数，容斥原理，博弈论等内容。</p></blockquote><p>质数<br>AcWing 866. 试除法判定质数<br>AcWing 867. 分解质因数<br>AcWing 868. 筛质数<br>约数<br>AcWing 869. 试除法求约数<br>AcWing 870. 约数个数<br>AcWing 871. 约数之和<br>AcWing 872. 最大公约数<br>欧拉函数<br>AcWing 873. 欧拉函数<br>AcWing 874. 筛法求欧拉函数<br>快速幂<br>AcWing 875. 快速幂<br>AcWing 876. 快速幂求逆元<br>扩展欧几里得算法<br>AcWing 877. 扩展欧几里得算法<br>AcWing 878. 线性同余方程<br>中国剩余定理<br>AcWing 204. 表达整数的奇怪方式<br>高斯消元<br>AcWing 883. 高斯消元解线性方程组<br>AcWing 884. 高斯消元解异或线性方程组<br>求组合数<br>AcWing 885. 求组合数 I<br>AcWing 886. 求组合数 II<br>AcWing 887. 求组合数 III<br>AcWing 888. 求组合数 IV<br>AcWing 889. 满足条件的01序列<br>容斥原理<br>AcWing 890. 能被整除的数<br>博弈论<br>AcWing 891. Nim游戏<br>AcWing 892. 台阶-Nim游戏<br>AcWing 893. 集合-Nim游戏<br>AcWing 894. 拆分-Nim游戏</p><h3 id="第五讲-动态规划完成情况：18-18"><a href="#第五讲-动态规划完成情况：18-18" class="headerlink" title="第五讲 动态规划完成情况：18&#x2F;18"></a>第五讲 动态规划完成情况：18&#x2F;18</h3><blockquote><p>包括背包问题，线性DP，区间DP，计数类DP，数位统计DP，状态压缩DP，树形DP，记忆化搜索等内容。</p></blockquote><p>背包问题<br>AcWing 2. 01背包问题<br>AcWing 3. 完全背包问题<br>AcWing 4. 多重背包问题<br>AcWing 5. 多重背包问题 II<br>AcWing 9. 分组背包问题<br>线性DP<br>AcWing 898. 数字三角形<br>AcWing 895. 最长上升子序列<br>AcWing 896. 最长上升子序列 II<br>AcWing 897. 最长公共子序列<br>AcWing 902. 最短编辑距离<br>AcWing 899. 编辑距离<br>区间DP<br>AcWing 282. 石子合并<br>计数类DP<br>AcWing 900. 整数划分<br>数位统计DP<br>AcWing 338. 计数问题<br>状态压缩DP<br>AcWing 291. 蒙德里安的梦想<br>AcWing 91. 最短Hamilton路径<br>树形DP<br>AcWing 285. 没有上司的舞会<br>记忆化搜索<br>AcWing 901. 滑雪</p><h3 id="第六讲-贪心完成情况：8-8"><a href="#第六讲-贪心完成情况：8-8" class="headerlink" title="第六讲 贪心完成情况：8&#x2F;8"></a>第六讲 贪心完成情况：8&#x2F;8</h3><blockquote><p>包括区间问题，Huffman树，排序不等式，绝对值不等式，推公式等内容。</p></blockquote><p>区间问题<br>AcWing 905. 区间选点<br>AcWing 908. 最大不相交区间数量<br>AcWing 906. 区间分组<br>AcWing 907. 区间覆盖<br>Huffman树<br>AcWing 148. 合并果子<br>排序不等式<br>AcWing 913. 排队打水<br>绝对值不等式<br>AcWing 104. 货仓选址<br>推公式<br>AcWing 125. 耍杂技的牛</p>]]></content>
    
    
    <categories>
      
      <category>寒假练题计划</category>
      
      <category>题单</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>algorithm</tag>
      
      <tag>ACwing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ChatCUMT</title>
    <link href="/2025/01/17/ChatCUMT/"/>
    <url>/2025/01/17/ChatCUMT/</url>
    
    <content type="html"><![CDATA[<h2 id="矿小言-基于大模型和知识图谱的校园知识问答系统"><a href="#矿小言-基于大模型和知识图谱的校园知识问答系统" class="headerlink" title="矿小言 - 基于大模型和知识图谱的校园知识问答系统"></a>矿小言 - 基于大模型和知识图谱的校园知识问答系统</h2><h3 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h3><p>矿小言(原名矿大知识平台)是一个集学习与研究辅助功能于一体的知识管理与服务平台。它通过整合校园知识资源，利用自然语言处理技术，为用户提供智能对话、知识图谱可视化展示、文件上传与存储、多模式对话等功能，旨在打造一个全面、便捷、高效的知识获取与应用环境。</p><p>项目应用场景图如下：</p><p><img src="https://pic--oss.oss-cn-beijing.aliyuncs.com/img/572802ee96e2f87cc09c764d72eddd5.png" alt="572802ee96e2f87cc09c764d72eddd5"></p><h3 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h3><ul><li><strong>前端仓库</strong>：<a href="https://github.com/666xz666/ChatCUMT-UI">ChatCUMT-UI</a> - 负责平台的用户界面设计与交互，提供用户友好的操作体验。</li><li><strong>后端仓库</strong>：<a href="https://github.com/666xz666/langchain-graph-builder">langchain-graph-builder</a> - 基于langchain、知识图谱、RAG技术构建知识库，实现知识的系统化整合与智能化管理。</li></ul><h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h3><ul><li><strong>智能对话</strong>：基于自然语言处理技术，用户可与系统进行日常交流式的互动，快速获取所需信息。</li></ul><p><img src="https://pic--oss.oss-cn-beijing.aliyuncs.com/img/e5f2c7406c38056e40b79b3da793fa3.png" alt="e5f2c7406c38056e40b79b3da793fa3"></p><ul><li><strong>知识图谱可视化</strong>：以图形化方式直观展现复杂知识体系，帮助用户理解知识点间的内在联系。</li></ul><p><img src="https://pic--oss.oss-cn-beijing.aliyuncs.com/img/69cc48a15134fa7445b5d0830137747.png" alt="69cc48a15134fa7445b5d0830137747"></p><ul><li><strong>文件上传与存储</strong>：支持多种文件格式上传，方便用户管理学习资料与科研项目资料。</li></ul><p><img src="https://pic--oss.oss-cn-beijing.aliyuncs.com/img/4bd824b15e5fb08846e9c7e9ce77552.png" alt="4bd824b15e5fb08846e9c7e9ce77552"></p><ul><li><strong>多模式对话</strong>：提供联网搜索、知识库RAG检索、知识图谱检索、文件对话等多种模式，满足不同场景需求。</li></ul><p><img src="https://pic--oss.oss-cn-beijing.aliyuncs.com/img/eead1f3b65571c24179d4c1d47a6977.png" alt="eead1f3b65571c24179d4c1d47a6977"></p><ul><li><strong>系统设置</strong>：用户可个性化调整模型调用、API Key配置等，实现定制化使用体验。</li></ul><p><img src="https://pic--oss.oss-cn-beijing.aliyuncs.com/img/17d1466f757753bfbfa754eee529cf3.png" alt="17d1466f757753bfbfa754eee529cf3"><br><img src="https://pic--oss.oss-cn-beijing.aliyuncs.com/img/1c90d99a80844c645c89a4c1a9cfa71.png" alt="1c90d99a80844c645c89a4c1a9cfa71"></p><h3 id="快速启动"><a href="#快速启动" class="headerlink" title="快速启动"></a>快速启动</h3><ol><li>前端启动：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm i<br>npm run serve<br></code></pre></td></tr></table></figure><ol start="2"><li>后端部署参考：<a href="https://github.com/666xz666/langchain-graph-builder/blob/main/README.md">langchain-graph-builder 文档</a></li></ol><h3 id="开发与维护"><a href="#开发与维护" class="headerlink" title="开发与维护"></a>开发与维护</h3><ul><li><strong>前端开发</strong>：使用现代前端<code>vue</code>技术栈构建，注重用户体验与界面美观。</li><li><strong>后端开发</strong>：基于<code>langchain</code>等技术实现知识库的高效构建与管理，确保系统稳定运行。</li><li><strong>持续更新</strong>：定期更新知识库与系统功能，修复已知问题，提升平台性能。</li></ul>]]></content>
    
    
    <categories>
      
      <category>666xz666的Github项目</category>
      
      <category>nlp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>langchain</tag>
      
      <tag>knowledge graph</tag>
      
      <tag>rag</tag>
      
      <tag>graphrag</tag>
      
      <tag>vue</tag>
      
      <tag>neo4j</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>langchain-graph-builder</title>
    <link href="/2025/01/17/lgb/"/>
    <url>/2025/01/17/lgb/</url>
    
    <content type="html"><![CDATA[<h1 id="langchain-graph-builder"><a href="#langchain-graph-builder" class="headerlink" title="langchain-graph-builder"></a>langchain-graph-builder</h1><p><a href="./README_en.md">English documentation</a></p><h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><p>langchain-graph-builder 是一个基于 FastAPI 构建的后端服务项目，旨在为知识库的创建、管理以及与之相关的对话功能提供接口支持。通过该项目，用户可以方便地创建知识库、上传文件至知识库、获取文件内容、删除知识库、生成知识库文件向量、获取知识库信息、进行大模型流式对话以及 RAG&#x2F;GraphRAG 对话等操作，同时还支持创建知识库图谱。</p><p><img src="https://pic--oss.oss-cn-beijing.aliyuncs.com/img/2b882cb22ba101d4ed8d4fc0adf9d0a.png" alt="2b882cb22ba101d4ed8d4fc0adf9d0a"></p><h2 id="已经实现的功能"><a href="#已经实现的功能" class="headerlink" title="已经实现的功能"></a>已经实现的功能</h2><h3 id="1-知识库"><a href="#1-知识库" class="headerlink" title="1. 知识库"></a>1. 知识库</h3><ul><li><p>上传文件构建知识库</p></li><li><p>知识库向量化</p></li><li><p>利用大模型结构化输出从向量库构建知识图谱</p></li><li><p>以不同的level删除知识库</p></li></ul><h3 id="2-对话"><a href="#2-对话" class="headerlink" title="2. 对话"></a>2. 对话</h3><ul><li><p>流式对话</p></li><li><p>RAG对话</p></li><li><p>联网解析网页对话</p></li><li><p>GraphRAG对话</p></li></ul><h2 id="快速启动"><a href="#快速启动" class="headerlink" title="快速启动"></a>快速启动</h2><h3 id="1-配置环境"><a href="#1-配置环境" class="headerlink" title="1. 配置环境"></a>1. 配置环境</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/666xz666/langchain-graph-builder.git<br>cd langchain-graph-builder<br><br>conda create -n lgb python=3.11 -y<br>conda activate lgb<br><br>pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple<br></code></pre></td></tr></table></figure><h3 id="2-复制配置文件"><a href="#2-复制配置文件" class="headerlink" title="2. 复制配置文件"></a>2. 复制配置文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python config_tool.py --copy<br></code></pre></td></tr></table></figure><h3 id="3-配置模型"><a href="#3-配置模型" class="headerlink" title="3. 配置模型"></a>3. 配置模型</h3><p>配置大模型api key</p><p>embedding模型下载:</p><p> <a href="https://pan.baidu.com/s/1XKQfFnSLbF0AjTLy_BCeFQ?pwd=fkrv">https://pan.baidu.com/s/1XKQfFnSLbF0AjTLy_BCeFQ?pwd=fkrv</a> </p><h3 id="4-配置neo4j"><a href="#4-配置neo4j" class="headerlink" title="4. 配置neo4j"></a>4. 配置neo4j</h3><p>安装neo4j 5.21.0, 配置apoc</p><p><a href="https://blog.csdn.net/m0_63593482/article/details/133096869">https://blog.csdn.net/m0_63593482/article/details/133096869</a></p><h3 id="5-配置路径信息"><a href="#5-配置路径信息" class="headerlink" title="5. 配置路径信息"></a>5. 配置路径信息</h3><p>知识库存储目录，日志目录, 模型路径等</p><h3 id="6-启动app"><a href="#6-启动app" class="headerlink" title="6. 启动app"></a>6. 启动app</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python app.py<br></code></pre></td></tr></table></figure><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>启动后在<code>&lt;host&gt;:&lt;port&gt;/redoc</code>能查看文档</p><p><img src="https://pic--oss.oss-cn-beijing.aliyuncs.com/img/fa48a08dea405ac3d0b043960cb1102.png" alt="fa48a08dea405ac3d0b043960cb1102"></p><h2 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="1-“No-module-named-pwd”（for-Windows）"><a href="#1-“No-module-named-pwd”（for-Windows）" class="headerlink" title="1.  “No module named pwd”（for Windows）"></a>1.  “No module named pwd”（for Windows）</h3><p><a href="https://blog.csdn.net/qq_40821260/article/details/137644996">https://blog.csdn.net/qq_40821260/article/details/137644996</a></p>]]></content>
    
    
    <categories>
      
      <category>666xz666的Github项目</category>
      
      <category>nlp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>langchain</tag>
      
      <tag>knowledge graph</tag>
      
      <tag>rag</tag>
      
      <tag>graphrag</tag>
      
      <tag>neo4j</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>神录屏软件</title>
    <link href="/2025/01/17/%E7%A5%9E%E5%BD%95%E5%B1%8F%E8%BD%AF%E4%BB%B6/"/>
    <url>/2025/01/17/%E7%A5%9E%E5%BD%95%E5%B1%8F%E8%BD%AF%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="神录屏软件推荐-Captura"><a href="#神录屏软件推荐-Captura" class="headerlink" title="神录屏软件推荐 - Captura"></a>神录屏软件推荐 - Captura</h1><h2 id="推荐理由"><a href="#推荐理由" class="headerlink" title="推荐理由"></a>推荐理由</h2><ul><li>占空间很小</li></ul><p><img src="https://pic--oss.oss-cn-beijing.aliyuncs.com/img/image-20250117220342393.png" alt="image-20250117220342393"></p><p>就几个M你敢信？</p><ul><li>录制效果很清晰</li></ul><p>无需多言，直接展示：</p><p><img src="https://pic--oss.oss-cn-beijing.aliyuncs.com/img/2025-01-17-21-55-47.gif" alt="2025-01-17-21-55-47"></p><h2 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h2><p><a href="https://zhuanlan.zhihu.com/p/513568582">神级录屏软件Captura最详细安装及使用教程 - 知乎</a></p><h2 id="MP4转GIF"><a href="#MP4转GIF" class="headerlink" title="MP4转GIF"></a>MP4转GIF</h2><p><a href="https://cloudconvert.com/mp4-to-gif">MP4 to GIF | CloudConvert</a></p>]]></content>
    
    
    <categories>
      
      <category>实用工具推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tool</tag>
      
      <tag>software</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客文章导出为md</title>
    <link href="/2025/01/17/%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E5%AF%BC%E5%87%BA%E4%B8%BAmd/"/>
    <url>/2025/01/17/%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E5%AF%BC%E5%87%BA%E4%B8%BAmd/</url>
    
    <content type="html"><![CDATA[<h1 id="博客文章导出为md"><a href="#博客文章导出为md" class="headerlink" title="博客文章导出为md"></a>博客文章导出为md</h1><h2 id="为什么要弄这个"><a href="#为什么要弄这个" class="headerlink" title="为什么要弄这个"></a>为什么要弄这个</h2><p>由于博客文章内容是基于静态的md文件，我想找一个方法将发在CSDN上的文章全部导进来，结果我看到了这篇文章：</p><p><a href="https://blog.csdn.net/weixin_45871977/article/details/143170311">CSDN、掘金、简书博客文章如何转为Markdown?_csdn文章转markdown-CSDN博客</a></p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p>步骤很简单，就是浏览器打开文章页面，f12开发者模式，复制</p><p><code>“article_content”</code>一整个标签内容为outer HTML，然后打开下面网站：</p><p><a href="https://tool.lu/markdown/">markdown编辑器 - 在线工具</a></p><p>导入后即可下载md文件到本地。</p><h2 id="实操结果"><a href="#实操结果" class="headerlink" title="实操结果"></a>实操结果</h2><blockquote><p>参考内容：<a href="https://blog.csdn.net/Better_Xing/article/details/125246147">CSDN、掘金、简书博客文章如何转为Markdown?</a></p><blockquote><p>下面以CSDN博文为例</p></blockquote><p><strong>1.在CSDN博文页面点击右键，选择“检查”（Google浏览器为例）。</strong><br><img src="https://pic--oss.oss-cn-beijing.aliyuncs.com/img/1f1e6432db987d3471c8113139bee121.png" alt="在这里插入图片描述"></p><p><strong>2.在查看器中搜索“article_content”，找到对应内容，点击…复制为outerHTML。</strong><br><img src="https://pic--oss.oss-cn-beijing.aliyuncs.com/img/63c5a8638ca7b40d4a70098b7ccb37a4.png" alt="在这里插入图片描述"><br><img src="https://pic--oss.oss-cn-beijing.aliyuncs.com/img/cac221099996ce477d0bbe1847d81523.png" alt="在这里插入图片描述"><br><strong>3.打开网址<a href="https://tool.lu/markdown/%EF%BC%8C%E7%82%B9%E5%87%BBHTML2MD%EF%BC%8C%E7%B2%98%E8%B4%B4html%E4%BB%A3%E7%A0%81%EF%BC%8C%E8%BD%AC%E6%8D%A2%E6%88%90Markdown%E3%80%82">https://tool.lu/markdown/，点击HTML2MD，粘贴html代码，转换成Markdown。</a></strong><br><img src="https://pic--oss.oss-cn-beijing.aliyuncs.com/img/e80f4a75e11b62d5a03fe7888b5c6810.png" alt="在这里插入图片描述"><br><strong>4.大功告成，同理操作掘金、简书或其他平台上博客，可能不在是article_content，需要自己找下博客主体内容。</strong><br><img src="https://pic--oss.oss-cn-beijing.aliyuncs.com/img/275c5c0043dfdcc81e905d1cebc22702.png" alt="在这里插入图片描述"></p></blockquote><p>直接把原文拿过来了，有种套娃的美。:sweat_smile:</p>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
      <tag>tool</tag>
      
      <tag>CSDN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/01/17/hello-world/"/>
    <url>/2025/01/17/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test.md</title>
    <link href="/2025/01/17/test-md/"/>
    <url>/2025/01/17/test-md/</url>
    
    <content type="html"><![CDATA[<h1 id="This-is-a-post-for-test"><a href="#This-is-a-post-for-test" class="headerlink" title="This is a post for test"></a>This is a post for test</h1><p>本文是对新博客编辑器功能的测试。</p><p><a href="https://hexo.fluid-dev.com/docs/guide/">配置指南</a></p><h2 id="1-Mermaid"><a href="#1-Mermaid" class="headerlink" title="1. Mermaid"></a>1. Mermaid</h2><p><img src="https://pic--oss.oss-cn-beijing.aliyuncs.com/img/image-20250117203928093.png" alt="image-20250117203928093"></p><p><img src="https://pic--oss.oss-cn-beijing.aliyuncs.com/img/image-20250117204058222.png" alt="image-20250117204058222"></p><pre><code class=" mermaid">graph TD    A[Alice] --&gt; B[Bob]    A --&gt; C[Carol]    B --&gt; D[Dave]    C --&gt; D    C --&gt; E[Eve]    D --&gt; F[Frank]    E --&gt; F    E --&gt; G[Gina]    F --&gt; G</code></pre><pre><code class=" mermaid">classDiagram  class User &#123;    -String email    -String phone    -String password    -String nickname    -String avatar    -List&lt;DownloadRecord&gt; downloadRecords    -List&lt;ExerciseRecord&gt; exerciseRecords    +login()    +register()    +uploadFile()    +downloadFile()    +viewDownloadRecords()    +viewExerciseRecords()    +reviewErrorQuestions()  &#125;  class DownloadRecord &#123;    -String fileId    -String fileName    -Date downloadTime  &#125;  class ExerciseRecord &#123;    -String questionId    -String questionContent    -String userAnswer    -Boolean isCorrect    -Date exerciseTime  &#125;  class KnowledgeFile &#123;    -String fileId    -String fileName    -String fileType    -String fileContent    -Date uploadTime    -User uploader    +parseFile()  &#125;  class QuestionBank &#123;    -String bankId    -String bankName    -List&lt;Question&gt; questions    +addQuestion()    +removeQuestion()    +searchQuestion()  &#125;  class Question &#123;    -String questionId    -String questionContent    -String answer    -String questionType    -Integer difficulty    +checkAnswer()  &#125;  class Admin &#123;    -String adminId    -String adminName    -String password    +login()    +uploadQuestionBank()    +crawlQuestionBank()    +importQuestionBank()  &#125;  class Recommendation &#123;    -User user    +recommendResources()    +generateStudyPlan()  &#125;  class Community &#123;    -List&lt;User&gt; users    +discussQuestion()    +shareExperience()    +sendPrivateMessage()    +likePost()    +commentPost()  &#125;  class DataAnalysis &#123;    -User user    +analyzeExerciseData()    +generateLearningReport()    +exportReport()  &#125;  User &quot;1&quot; -- &quot;*&quot; DownloadRecord  User &quot;1&quot; -- &quot;*&quot; ExerciseRecord  KnowledgeFile &quot;1&quot; -- &quot;1&quot; User  QuestionBank &quot;1&quot; -- &quot;*&quot; Question  Recommendation &quot;1&quot; -- &quot;1&quot; User  Community &quot;1&quot; -- &quot;*&quot; User  DataAnalysis &quot;1&quot; -- &quot;1&quot; User</code></pre><h2 id="2-公式"><a href="#2-公式" class="headerlink" title="2. 公式"></a>2. 公式</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs latex">单行使用一个<span class="hljs-built_in">$</span>符号，换行使用两个<span class="hljs-built_in">$</span>符号<br>计算公式1：<span class="hljs-built_in">$</span><span class="hljs-keyword">\int</span><span class="hljs-built_in">_</span>&#123;a&#125;<span class="hljs-built_in">^</span>&#123;b&#125; x<span class="hljs-built_in">^</span>2 dx<span class="hljs-built_in">$</span>&lt;br&gt;计算公式2：<span class="hljs-built_in">$</span><span class="hljs-keyword">\int</span><span class="hljs-built_in">_</span>&#123;a&#125;<span class="hljs-built_in">^</span>&#123;b&#125; x<span class="hljs-built_in">^</span>3 dx<span class="hljs-built_in">$</span>&lt;br&gt;<span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><span class="hljs-keyword">\int</span><span class="hljs-built_in">_</span>&#123;a&#125;<span class="hljs-built_in">^</span>&#123;b&#125; x<span class="hljs-built_in">^</span>2 dx<span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br>Q = XW<span class="hljs-built_in">^</span>Q, <span class="hljs-keyword">\quad</span> K = XW<span class="hljs-built_in">^</span>K, <span class="hljs-keyword">\quad</span> V = XW<span class="hljs-built_in">^</span>V<br><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br><br></code></pre></td></tr></table></figure><p>单行使用一个$符号，换行使用两个$符号<br>计算公式1：$\int_{a}^{b} x^2 dx$<br>计算公式2：$\int_{a}^{b} x^3 dx$<br>$$\int_{a}^{b} x^2 dx$$<br>$$<br>Q &#x3D; XW^Q, \quad K &#x3D; XW^K, \quad V &#x3D; XW^V<br>$$</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;hello world&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>…</p>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>test</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
